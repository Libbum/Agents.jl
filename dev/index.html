<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Agents.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Agents.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Introduction</a><ul class="internal"><li><a class="toctext" href="#Other-features-1">Other features</a></li><li><a class="toctext" href="#Why-we-need-agent-based-modeling-1">Why we need agent-based modeling</a></li><li><a class="toctext" href="#Tutorial-1">Tutorial</a></li><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Table-of-contents-1">Table of contents</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="schelling/">Schelling&#39;s segregation model</a></li><li><a class="toctext" href="boltzmann_example01/">Boltzmann wealth distribution</a></li><li><a class="toctext" href="forest_fire/">Forest fire</a></li><li><a class="toctext" href="CA/">Cellular Automata</a></li></ul></li><li><a class="toctext" href="builtin_functions/">Built-in funtions</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Introduction</a></li></ul><a class="edit-page" href="https://github.com/kavir1698/Agents.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Agents.jl-Documentation-1" href="#Agents.jl-Documentation-1">Agents.jl Documentation</a></h1><p>Agents.jl is a <a href="https://julialang.org/">Julia</a> framework for an agent-based modeling (ABM). It provides a structure and components for quickly implementing agent-based models, run them in batch, collect data, and visualize them. To that end, it provides the following functionalities: </p><ul><li>Default grids to run the simulation, including simple or toroidal 1D grids, simple or toroidal regular rectangular and triangular 2D grids, and simple or toroidal regular cubic 3D grids with von Neumann or Moore neighborhoods. Users can use their defined graphs too.</li><li>Automatic data collection in a <code>DataFrame</code> at desired intervals.</li><li>Exploring the simulation results interactively in <a href="https://github.com/vega/voyager">Data Voyegar 2</a>.</li><li>Batch running and batch data collection</li><li>Visualize agent distributions on grids</li></ul><p>Many agent-based modeling frameworks have been constructed to ease the process of building and analyzing ABMs (see <a href="http://dx.doi.org/10.1016/j.cosrev.2017.03.001">here</a> for a review). Notable examples are <a href="https://ccl.northwestern.edu/netlogo/">NetLogo</a>, <a href="https://repast.github.io/index.html">Repast</a>, <a href="https://journals.sagepub.com/doi/10.1177/0037549705058073">MASON</a>, and <a href="https://github.com/projectmesa/mesa">Mesa</a>. Implementing an ABM framework in Julia has several advantages. First, using a general purpose programming language instead of a custom scripting language, such as NetLogo&#39;s, removes a learning step and provides a single environment for building the models and analyzing their results. Julia has a rich ecosystem for data analysis and visualization. Second, Julia is easier-to-use than Java (used for Repast and MASON), and provides a REPL (Read-Eval-Print-Loop) environment to build and analyze models interactively. Third, unlike Python (used for Mesa), Julia is easy-to-write but also fast to run. This is a crucial criterion for models that require considerable computations.</p><p>Agents.jl provides users with core components that make it easy to build ABMS, run them in batch, collect model outputs, and visualize the results. Briefly, the framework eases the following tasks for the user, and is at the same time flexible enough to allow implementation of almost any ABM. <strong>Schedulers</strong>: users can choose from a range of activation regimes,i.e. the order with which agents activate, or implement a custom one. <strong>Spatial structures</strong>: the framework implements 1D, 2D, and 3D grids which can optionally have periodic boundary conditions, meaning that edges of a grid connect to their opposite edges. An agent exiting from one edge enters the grid from the opposite edge. Moreover, users can construct irregular networks as the space where the agents live. <strong>Data collection</strong>: users only specify the kind of data they need and the framework automatically collects them in a table. The collected data are then ready to be analyzed and visualized. <strong>Visualization</strong> users can create custom plots interactively from the simulation outputs using the <a href="https://github.com/vega/voyager">Data Voyager</a> platform. Furthermore, they can visualize agent distributions on 2D grids. <strong>Batch run</strong>: in agent-based modeling, we can rarely make conclusions from single simulation runs. Instead we run many replicates of a simulation and observe the mean behavior of the system. Agents.jl automates running simulation replicates and collecting and aggregating their results.</p><p>Agents.jl is lightweight and modular. It has a short learning curve, and allows one to extend its capabilities and express complicated modeling scenarios. Agents.jl is inspired by <a href="https://github.com/projectmesa/mesa">Mesa</a> framework for Python.</p><h2><a class="nav-anchor" id="Other-features-1" href="#Other-features-1">Other features</a></h2><h3><a class="nav-anchor" id="Aggregating-collected-data-1" href="#Aggregating-collected-data-1">Aggregating collected data</a></h3><p>Sometimes, it is easier to take summary statistics than collect all the raw data. The <code>step!</code> function accepts a list of aggregating functions, e.g. <code>mean</code> and <code>median</code>. If such a list is provided, each function will apply to a list of the agent fields at each step. Only the summary statistics will be returned. It is possible to pass a dictionary of agent fields and aggregator functions that only apply to those fields. To collect data from the model object, pass <code>:model</code> instead of an agent field. To collect data from a list of agent objects, rather than a list of agents&#39; fields, pass <code>:agent</code>.</p><h3><a class="nav-anchor" id="Running-multiple-replicates-1" href="#Running-multiple-replicates-1">Running multiple replicates</a></h3><p>Since ABMs are stochastic, researchers often run multiple replicates of a simulation and observe its mean behavior. Agents.jl provides the <code>batchrunner</code> function which allows running and collecting data from multiple simulation replicates. Furthermore, the <code>combine_columns!</code> function merges the results of simulation replicates into single columns using user-passed aggregator functions.</p><h3><a class="nav-anchor" id="Exploratory-data-analysis-1" href="#Exploratory-data-analysis-1">Exploratory data analysis</a></h3><p>Julia has extensive tools for data analysis. Having the results of simulations in <code>DataFrame</code> format makes it easy to take advantage of most of such tools. Examples include the VegaLite.jl package for data visualization, which uses a grammar of graphics syntax to produce interactive plots. Moreover, DataVoyager.jl provides an <a href="https://github.com/vega/voyager">interactive environment</a> to build custom plots from <code>DataFrame</code>s. Agents.jl provides <code>visualize_data</code> function that sends the simulation outputs to Data Voyager. </p><h2><a class="nav-anchor" id="Why-we-need-agent-based-modeling-1" href="#Why-we-need-agent-based-modeling-1">Why we need agent-based modeling</a></h2><p>Agent-based models (ABMs) are increasingly recognized as the approach for studying complex systems. Complex systems cannot be fully understood using the traditional mathematical tools that aggregate the behavior of elements in a system. The behavior of a complex system depends on the behavior and interaction of its elements (agents). Small changes in the input to complex systems or the behavior of its agents can lead to large changes in system&#39;s outcome. That is to say a complex system&#39;s behavior is nonlinear, and that it is not the sum of the behavior of its elements. Use of ABMs have become feasible after the availability of computers and has been growing since, especially in modeling biological and economical systems, and has extended to social studies and archeology.</p><p>An ABM consists of autonomous agents that behave given a set of rules. A classic and simple example of an ABM is a cellular automaton. A cellular automaton is a regular grid where each <em>cell</em> is an agent. Cells have different <em>states</em>, for example, on or off. A cell&#39;s state can change at each step depending on the state of its <em>neighbors</em>. This simple model can lead to unpredicted emergent patterns on the grid. Famous examples of which are Wolfram&#39;s rule 22 and rule 30 (see <a href="https://link.aps.org/doi/10.1103/RevModPhys.55.601">here</a> and figure below).</p><p><img src="CA1D_22.png" alt="Wolfram&#39;s rule 22 implemented in Agents.jl"/> <img src="CA1D_30.png" alt="Wolfram&#39;s rule 30 implemented in Agents.jl"/></p><p>Another classic example of an ABM is <a href="https://www.tandfonline.com/doi/abs/10.1080/0022250X.1971.9989794">Schelling&#39;s segregation model</a>. This model also uses a regular grid and defines agents as the cells of the grid. Agents can be from different social groups. Agents are happy/unhappy based on the fraction of their neighbors that belong to the same group as they are. If they are unhappy, they keep moving to new locations until they are happy. Schelling&#39;s model shows that even small preferences of agents to have neighbors belonging to the same group (e.g. preferring that at least 30% of neighbors to be in the same group) could lead to total segregation of neighborhoods. This is another example of an emergent phenomenon from simple interactions of agents.</p><h2><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h2><p>For a quick tutorial see the example models. I recommend starting with Schelling&#39;s segregation model.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The package is in Julia&#39;s package list. Install it using this command:</p><pre><code class="language-julia">]add Agents</code></pre><h2><a class="nav-anchor" id="Table-of-contents-1" href="#Table-of-contents-1">Table of contents</a></h2><ul><li><a href="forest_fire/#Forest-fire-model-1">Forest fire model</a></li><li><a href="boltzmann_example01/#Boltzmann-wealth-distribution-1">Boltzmann wealth distribution</a></li><ul><li><a href="boltzmann_example01/#Building-the-model-1">Building the model</a></li></ul><li><a href="schelling/#Schelling&#39;s-segregation-model-1">Schelling&#39;s segregation model</a></li><ul><li><a href="schelling/#Agents.jl&#39;s-architecture-1">Agents.jl&#39;s architecture</a></li></ul><li><a href="builtin_functions/#Built-in-function-1">Built-in function</a></li><ul><li><a href="builtin_functions/#Scheduler-functions-1">Scheduler functions</a></li><li><a href="builtin_functions/#Space-functions-1">Space functions</a></li><li><a href="builtin_functions/#Model-functions-1">Model functions</a></li><li><a href="builtin_functions/#Data-collectors-1">Data collectors</a></li><li><a href="builtin_functions/#Batch-runner-1">Batch runner</a></li><li><a href="builtin_functions/#Visualization-functions-1">Visualization functions</a></li></ul><li><a href="#Agents.jl-Documentation-1">Agents.jl Documentation</a></li><ul><li><a href="#Other-features-1">Other features</a></li><li><a href="#Why-we-need-agent-based-modeling-1">Why we need agent-based modeling</a></li><li><a href="#Tutorial-1">Tutorial</a></li><li><a href="#Installation-1">Installation</a></li><li><a href="#Table-of-contents-1">Table of contents</a></li></ul></ul><footer><hr/><a class="next" href="schelling/"><span class="direction">Next</span><span class="title">Schelling&#39;s segregation model</span></a></footer></article></body></html>
