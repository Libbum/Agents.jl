<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#.-The-model-1"><span>1. The model</span></a></li><li><a class="tocitem" href="#.-The-space-1"><span>2. The space</span></a></li><li><a class="tocitem" href="#.-The-agent-1"><span>3. The agent</span></a></li><li><a class="tocitem" href="#.-The-stepping-function-1"><span>4. The stepping function</span></a></li><li><a class="tocitem" href="#.-Running-the-model-and-collecting-data-1"><span>5. Running the model &amp; collecting data</span></a></li><li><a class="tocitem" href="#An-educative-example-1"><span>An educative example</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../examples/forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../examples/game_of_life_2D_CA/">Game of life</a></li><li><a class="tocitem" href="../examples/rule22_1D_CA/">Rule 22</a></li><li><a class="tocitem" href="../examples/wright-fisher/">Wright-Fisher model of evolution</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../mesa/">Comparison against Mesa (Python)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-1"><a class="docs-heading-anchor" href="#Tutorial-1">Tutorial</a><a class="docs-heading-anchor-permalink" href="#Tutorial-1" title="Permalink"></a></h1><p>Agents.jl is composed of components for building models, building and managing space structures, collecting data, running batch simulations, and data visualization.</p><p>Agents.jl structures simulations in three components: a <em>model</em> component that keeps all model-level variables and data, an <em>agent</em> component that keeps all agent-level variables and data, and a <em>space</em> component that represents the space where the agents live.</p><p>For building any Agent-Based-Model (ABM), users have to define at least the following four quantities:</p><ol><li>An <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> instance.</li><li>A <a href="#Agents.Space"><code>Space</code></a> instance.  </li><li>A subtype of <a href="#Agents.AbstractAgent"><code>AbstractAgent</code></a> for the agents.</li><li>A stepping function that controls how the agents and the model evolve.</li></ol><p>With these, Agents.jl&#39;s tools manage the rest of the path to producing and processing data, as well as visualizations (Fig. 1).</p><p><img src="../overviewModel.png" alt="Fig. 1. __Path from building a model to gaining information from the model using Agents.jl.__ The box in cyan is what the user has to provide and the boxes in green are what Agents.jl provides."/></p><hr/><p><img src="../overviewModelObject.png" alt="Fig. 2. __Fields of a model object and their types.__"/></p><h2 id=".-The-model-1"><a class="docs-heading-anchor" href="#.-The-model-1">1. The model</a><a class="docs-heading-anchor-permalink" href="#.-The-model-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentBasedModel" href="#Agents.AgentBasedModel"><code>Agents.AgentBasedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AgentBasedModel(agent_type [, space]; scheduler, properties)</code></pre><p>Create an agent based model from the given agent type, and the <code>space</code> (from <a href="#Agents.Space"><code>Space</code></a>). <code>ABM</code> is equivalent with <code>AgentBasedModel</code>. The agents are stored in a dictionary <code>model.agents</code>, where the keys are the agent IDs, while the values are the agents themselves. It is recommended however to use <a href="../api/#Agents.id2agent"><code>id2agent</code></a> to get an agent.</p><p><code>space</code> can be omitted, in which it will equal to <code>nothing</code>. This means that all agents are virtualy in one node and have no spatial structure. If space is omitted, some functions that fascilitate agent-space interactions will not work.</p><p>Optionally provide a <code>scheduler</code> that creates the order with which agents are activated in the model, and <code>properties</code> for additional model-level properties. This is accessed as <code>model.properties</code> for later use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/95cb4d5d08208e1348e920f07cf219b766c5fc78/src/core/model.jl#L43-L60">source</a></section></article><p>The model type may not necessarily be a mutable type, it depends on your problem.</p><h2 id=".-The-space-1"><a class="docs-heading-anchor" href="#.-The-space-1">2. The space</a><a class="docs-heading-anchor-permalink" href="#.-The-space-1" title="Permalink"></a></h2><p>Under the hood, all spaces are represented by a graph from LightGraphs.jl. However, if your space is a regular grid then there is some additional functionality that allows converting graph nodes to coordinates on the multidimensional grid.</p><p>Regardless, in every case you initialize your space by calling <code>Space</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.Space" href="#Agents.Space"><code>Agents.Space</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Space(graph::AbstractGraph) -&gt; GraphSpace</code></pre><p>Create a space instance that is underlined by an arbitrary graph. In this case, your agent positions (field <code>pos</code>) should be of type <code>Integer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/95cb4d5d08208e1348e920f07cf219b766c5fc78/src/core/space.jl#L50-L54">source</a></section><section><div><pre><code class="language-none">Space(dims::NTuple; periodic = false, moore = false) -&gt; GridSpace</code></pre><p>Create a space instance that represents a grid of dimensionality <code>length(dims)</code>, with each dimension having the size of the corresponding entry of <code>dims</code>. In this case, your agent positions (field <code>pos</code>) should be of type <code>NTuple{Int}</code>.</p><p>The two keyword arguments denote if the grid should be periodic on its ends, and if the connections should be of type Moore or not (in the Moore case the diagonal connections are also valid. E.g. for a 2D grid, each node has 8 neighbors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/95cb4d5d08208e1348e920f07cf219b766c5fc78/src/core/space.jl#L60-L70">source</a></section></article><h2 id=".-The-agent-1"><a class="docs-heading-anchor" href="#.-The-agent-1">3. The agent</a><a class="docs-heading-anchor-permalink" href="#.-The-agent-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.AbstractAgent" href="#Agents.AbstractAgent"><code>Agents.AbstractAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All agents must be a mutable subtype of <code>AbstractAgent</code>. Your agent type <strong>must have</strong> at least the <code>id</code> field, and if there is a space structure the <code>pos</code> field, (fields are expected in this order)</p><pre><code class="language-julia">mutable struct MyAgent{P} &lt;: AbstractAgent
    id::Int
    pos::P
end</code></pre><p>Only for grid spaces, <code>pos</code> can be an <code>NTuple</code>. For arbitrary graph spaces it must always be an integer (the graph node number).</p><p>Your agent type may have other additional fields relevant to your system, for example variable quantities like &quot;status&quot; or other &quot;counters&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/95cb4d5d08208e1348e920f07cf219b766c5fc78/src/core/model.jl#L7-L22">source</a></section></article><p>The agent type <strong>must</strong> be mutable. Once an Agent is created it can be added to a model using e.g. <a href="../api/#Agents.add_agent!"><code>add_agent!</code></a>. Then, the agent can interact with the model and the space further by using e.g. <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a> or <a href="../api/#Agents.kill_agent!"><code>kill_agent!</code></a>.</p><p>For more functions visit the <a href="../api/#API-1">API</a> page.</p><h2 id=".-The-stepping-function-1"><a class="docs-heading-anchor" href="#.-The-stepping-function-1">4. The stepping function</a><a class="docs-heading-anchor-permalink" href="#.-The-stepping-function-1" title="Permalink"></a></h2><p>Any ABM model should have at least one and at most two step functions. An <em>agent step function</em> is always required. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a <em>model step function</em>.</p><p>An agent step function should only accept two arguments: first, an agent object, and second, a model object.</p><p>The model step function should accept only one argument, that is the model object. To use only a model step function, users can use the built-in <code>dummystep</code> as the agent step function.</p><h2 id=".-Running-the-model-and-collecting-data-1"><a class="docs-heading-anchor" href="#.-Running-the-model-and-collecting-data-1">5. Running the model &amp; collecting data</a><a class="docs-heading-anchor-permalink" href="#.-Running-the-model-and-collecting-data-1" title="Permalink"></a></h2><p>After the basic types and functions are defined, we can run the model using the built-in <code>step!</code> function. This will update the agents and the model as defined by the agent and model stepping functions. In addition, by providing keywords to <code>step!</code>, it is also possible to collect and process data while the model evolves.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.step!" href="#Agents.step!"><code>Agents.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step!(model, agent_step! [, model_step!], n::Integer = 1)</code></pre><p>Update agents <code>n</code> steps. Agents will be updated as specified by the <code>model.scheduler</code>. If given the optional function <code>model_step!</code>, it is triggered <em>after</em> every scheduled agent has acted.</p><pre><code class="language-none">step!(model, agent_step! [, model_step!], n::Function)</code></pre><p><code>n</code> can be also be a function that takes as an input the <code>model</code> and returns <code>true/false</code>. Then <code>step!</code> runs the model until <code>n(model)</code> returns <code>true</code>.</p><pre><code class="language-none">step!(model, agent_step! [, model_step!], n, properties; kwargs...)</code></pre><p>This version of <code>step!</code>, with the <code>properties</code> argument and extra keywords, performs data collection/processing while running the model.</p><p><code>properties</code> dictates which agent fields should be collected as data. It can be either an array, in which case, the specified fields of all agents will be saved. Or it can be a dictionary, in which case it should map agent fields (<code>Symbol</code>) to functions.</p><p>If <code>properties</code> is an array, each row of the output <code>DataFrame</code> corresponds to a single agent and each column is a requested field value.</p><p>If <code>properties</code> is a dictionary, each row of the output <code>DataFrame</code> corresponds to all agents and each column is the a function applied to a field. The functions in a dictionary <code>properties</code> are applied to the collected fields, that is, the keys of <code>properties</code>. For example, if your agents have a field called <code>wealth</code>, and you want to calculate mean and median population wealth at steps defined by <code>when</code>, your <code>properties</code> dict will be <code>Dict(:wealth =&gt; [mean, median])</code>.</p><p>If an agent field returns an array instead of a single number, the mean of that array will be calculated before the functions are applied to them.</p><p>Collected data always also include the initial status of the model at step 0.</p><p>To apply a function to the list of agents, use <code>:agent</code> as a dictionary key. To apply a function to the model object, use <code>:model</code> as a dictionary key.</p><p><strong>Keywords</strong></p><ul><li><code>when=1:n</code> : at which steps <code>n</code> to perform the data collection and processing.</li><li><code>replicates</code> : Optional. Run <code>replicates</code> replicates of the simulation. Defaults to 0.</li><li><code>parallel</code> : Optional. Only when <code>replicates</code>&gt;0. Run replicate simulations in parallel. Defaults to <code>false</code>.</li><li><code>step0</code>: Whether to collect data at step zero, before running the model. Defaults to true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/95cb4d5d08208e1348e920f07cf219b766c5fc78/src/simulations/step.jl#L3-L49">source</a></section></article><p>Notice that besides <code>step!</code>, there is also the <a href="../api/#Agents.paramscan"><code>paramscan</code></a> function that performs data collection, while scanning ranges of the parameters of the model.</p><h2 id="An-educative-example-1"><a class="docs-heading-anchor" href="#An-educative-example-1">An educative example</a><a class="docs-heading-anchor-permalink" href="#An-educative-example-1" title="Permalink"></a></h2><p>A simple, education-oriented example of using the basic Agents.jl API is given in <a href="../examples/schelling/#Schelling&#39;s-segregation-model-1">Schelling&#39;s segregation model</a>. There the visualization aspect is also discussed.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../examples/schelling/">Schelling&#39;s segregation model »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 December 2019 12:50">Tuesday 24 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
