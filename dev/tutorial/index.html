<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Agents.jl&#39;s-basic-usage-1"><span>Agents.jl&#39;s basic usage</span></a></li><li><a class="tocitem" href="#Example:-Schelling&#39;s-segregation-model-1"><span>Example: Schelling&#39;s segregation model</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../examples/forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../examples/game_of_life_2D_CA/">Game of life</a></li><li><a class="tocitem" href="../examples/rule22_1D_CA/">Rule 22</a></li><li><a class="tocitem" href="../examples/wright-fisher/">Wright-Fisher model of evolution</a></li></ul></li><li><a class="tocitem" href="../mesa/">Comparison against Mesa (Python)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-1"><a class="docs-heading-anchor" href="#Tutorial-1">Tutorial</a><a class="docs-heading-anchor-permalink" href="#Tutorial-1" title="Permalink"></a></h1><h2 id="Agents.jl&#39;s-basic-usage-1"><a class="docs-heading-anchor" href="#Agents.jl&#39;s-basic-usage-1">Agents.jl&#39;s basic usage</a><a class="docs-heading-anchor-permalink" href="#Agents.jl&#39;s-basic-usage-1" title="Permalink"></a></h2><p>Agents.jl is composed of components for building models, building and managing space structures, collecting data, running batch simulations, and data visualization.</p><p>Agents.jl structures simulations in three components: a <em>model</em> component that keeps all model-level variables and data, an <em>agent</em> component that keeps all agent-level variables and data, and a <em>space</em> component that represents the space where the agents live.</p><p>For building any Agent-Based-Model (ABM), users have to define at least the following four quantities:</p><ol><li>An <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> instance.</li><li>A <a href="#Agents.Space"><code>Space</code></a> instance.  </li><li>A subtype of <a href="#Agents.AbstractAgent"><code>AbstractAgent</code></a> for the agents.</li><li>A stepping function that controls how the agents and the model evolve.</li></ol><p>With these, Agents.jl&#39;s tools manage the rest of the path to producing and processing data, as well as visualizations (Fig. 1).</p><p><img src="../overviewModel.png" alt="Fig. 1. __Path from building a model to gaining information from the model using Agents.jl.__ The box in cyan is what the user has to provide and the boxes in green are what Agents.jl provides."/></p><hr/><p><img src="../overviewModelObject.png" alt="Fig. 2. __Fields of a model object and their types.__"/></p><h3 id=".-The-model-1"><a class="docs-heading-anchor" href="#.-The-model-1">1. The model</a><a class="docs-heading-anchor-permalink" href="#.-The-model-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentBasedModel" href="#Agents.AgentBasedModel"><code>Agents.AgentBasedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AgentBasedModel(agent_type [, space]; scheduler, properties)</code></pre><p>Create an agent based model from the given agent type, and the <code>space</code> (from <a href="#Agents.Space"><code>Space</code></a>). <code>ABM</code> is equivalent with <code>AgentBasedModel</code>. The agents are stored in a dictionary <code>model.agents</code>, where the keys are the agent IDs, while the values are the agents themselves. It is recommended however to use <a href="../api/#Agents.id2agent"><code>id2agent</code></a> to get an agent.</p><p><code>space</code> can be omitted, in which it will equal to <code>nothing</code>. This means that all agents are virtualy in one node and have no spatial structure. If space is omitted, some functions that fascilitate agent-space interactions will not work.</p><p>Optionally provide a <code>scheduler</code> that creates the order with which agents are activated in the model, and <code>properties</code> for additional model-level properties. This is accessed as <code>model.properties</code> for later use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/ff64d2d9bd2eafeb0e235d2c9ff23fc1653defd2/src/core/model.jl#L43-L60">source</a></section></article><p>The model type may not necessarily be a mutable type, it depends on your problem.</p><h3 id=".-The-space-1"><a class="docs-heading-anchor" href="#.-The-space-1">2. The space</a><a class="docs-heading-anchor-permalink" href="#.-The-space-1" title="Permalink"></a></h3><p>Under the hood, all spaces are represented by a graph from LightGraphs.jl. However, if your space is a regular grid then there is some additional functionality that allows converting graph nodes to coordinates on the multidimensional grid.</p><p>Regardless, in every case you initialize your space by calling <code>Space</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.Space" href="#Agents.Space"><code>Agents.Space</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Space(graph::AbstractGraph) -&gt; GraphSpace</code></pre><p>Create a space instance that is underlined by an arbitrary graph. In this case, your agent positions (field <code>pos</code>) should be of type <code>Integer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/ff64d2d9bd2eafeb0e235d2c9ff23fc1653defd2/src/core/space.jl#L50-L54">source</a></section><section><div><pre><code class="language-none">Space(dims::NTuple; periodic = false, moore = false) -&gt; GridSpace</code></pre><p>Create a space instance that represents a grid of dimensionality <code>length(dims)</code>, with each dimension having the size of the corresponding entry of <code>dims</code>. In this case, your agent positions (field <code>pos</code>) should be of type <code>NTuple{Int}</code>.</p><p>The two keyword arguments denote if the grid should be periodic on its ends, and if the connections should be of type Moore or not (in the Moore case the diagonal connections are also valid. E.g. for a 2D grid, each node has 8 neighbors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/ff64d2d9bd2eafeb0e235d2c9ff23fc1653defd2/src/core/space.jl#L60-L70">source</a></section></article><h3 id=".-The-agent-1"><a class="docs-heading-anchor" href="#.-The-agent-1">3. The agent</a><a class="docs-heading-anchor-permalink" href="#.-The-agent-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.AbstractAgent" href="#Agents.AbstractAgent"><code>Agents.AbstractAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All agents must be a mutable subtype of <code>AbstractAgent</code>. Your agent type <strong>must have</strong> at least the <code>id</code> field, and if there is a space structure the <code>pos</code> field, (fields are expected in this order)</p><pre><code class="language-julia">mutable struct MyAgent{P} &lt;: AbstractAgent
    id::Int
    pos::P
end</code></pre><p>Only for grid spaces, <code>pos</code> can be an <code>NTuple</code>. For arbitrary graph spaces it must always be an integer (the graph node number).</p><p>Your agent type may have other additional fields relevant to your system, for example variable quantities like &quot;status&quot; or other &quot;counters&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/ff64d2d9bd2eafeb0e235d2c9ff23fc1653defd2/src/core/model.jl#L7-L22">source</a></section></article><p>The agent type <strong>must</strong> be mutable. Once an Agent is created it can be added to a model using e.g. <a href="../api/#Agents.add_agent!"><code>add_agent!</code></a>. Then, the agent can interact with the model and the space further by using e.g. <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a> or <a href="../api/#Agents.kill_agent!"><code>kill_agent!</code></a>.</p><p>For more functions visit the <a href="../api/#API-1">API</a> page.</p><h3 id=".-The-stepping-function-1"><a class="docs-heading-anchor" href="#.-The-stepping-function-1">4. The stepping function</a><a class="docs-heading-anchor-permalink" href="#.-The-stepping-function-1" title="Permalink"></a></h3><p>Any ABM model should have at least one and at most two step functions. An <em>agent step function</em> is always required. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a <em>model step function</em>.</p><p>An agent step function should only accept two arguments: first, an agent object, and second, a model object.</p><p>The model step function should accept only one argument, that is the model object. To use only a model step function, users can use the built-in <code>dummystep</code> as the agent step function.</p><h3 id=".-Running-the-model-and-collecting-data-1"><a class="docs-heading-anchor" href="#.-Running-the-model-and-collecting-data-1">5. Running the model &amp; collecting data</a><a class="docs-heading-anchor-permalink" href="#.-Running-the-model-and-collecting-data-1" title="Permalink"></a></h3><p>After the basic types and functions are defined, we can run the model using the built-in <code>step!</code> function. This will update the agents and the model as defined by the agent and model stepping functions. In addition, by providing keywords to <code>step!</code>, it is also possible to collect and process data while the model evolves.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.step!" href="#Agents.step!"><code>Agents.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step!(model, agent_step! [, model_step!], n::Integer = 1)</code></pre><p>Update agents <code>n</code> steps. Agents will be updated as specified by the <code>model.scheduler</code>. If given the optional function <code>model_step!</code>, it is triggered <em>after</em> every scheduled agent has acted.</p><pre><code class="language-none">step!(model, agent_step! [, model_step!], n::Function)</code></pre><p><code>n</code> can be also be a function that takes as an input the <code>model</code> and returns <code>true/false</code>. Then <code>step!</code> runs the model until <code>n(model)</code> returns <code>true</code>. </p><pre><code class="language-none">step!(model, agent_step! [, model_step!], n, properties; kwargs...)</code></pre><p>This version of <code>step!</code>, with the <code>properties</code> argument and extra keywords, performs data collection/processing while running the model.</p><p><code>properties</code> dictates which agent fields should be collected as data. It can be either an array, in which case, the specified fields of all agents will be saved. Or it can be a dictionary, in which case it should map agent fields (<code>Symbol</code>) to functions.</p><p>If <code>properties</code> is an array, each row of the output <code>DataFrame</code> corresponds to a single agent and each column is a requested field value.</p><p>If <code>properties</code> is a dictionary, each row of the output <code>DataFrame</code> corresponds to all agents and each column is the a function applied to a field. The functions in a dictionary <code>properties</code> are applied to the collected fields, that is, the keys of <code>properties</code>. For example, if your agents have a field called <code>wealth</code>, and you want to calculate mean and median population wealth at steps defined by <code>when</code>, your <code>properties</code> dict will be <code>Dict(:wealth =&gt; [mean, median])</code>.</p><p>If an agent field returns an array instead of a single number, the mean of that array will be calculated before the functions are applied to them.</p><p>Collected data always also include the initial status of the model at step 0.</p><p>To apply a function to the list of agents, use <code>:agent</code> as a dictionary key. To apply a function to the model object, use <code>:model</code> as a dictionary key.</p><p><strong>Keywords</strong></p><ul><li><code>when=1:n</code> : at which steps <code>n</code> to perform the data collection and processing.</li><li><code>replicates</code> : Optional. Run <code>replicates</code> replicates of the simulation. Defaults to 0.</li><li><code>parallel</code> : Optional. Only when <code>replicates</code>&gt;0. Run replicate simulations in parallel. Defaults to <code>false</code>.</li><li><code>step0</code>: Whether to collect data at step zero, before running the model. Defaults to true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/ff64d2d9bd2eafeb0e235d2c9ff23fc1653defd2/src/simulations/step.jl#L3-L49">source</a></section></article><p>Notice that besides <code>step!</code>, there is also the <a href="../api/#Agents.paramscan"><code>paramscan</code></a> function that performs data collection, while scanning ranges of the parameters of the model.</p><h2 id="Example:-Schelling&#39;s-segregation-model-1"><a class="docs-heading-anchor" href="#Example:-Schelling&#39;s-segregation-model-1">Example: Schelling&#39;s segregation model</a><a class="docs-heading-anchor-permalink" href="#Example:-Schelling&#39;s-segregation-model-1" title="Permalink"></a></h2><p>We now demonstrate Agents.jl&#39;s architecture and features through building the following definition of Schelling&#39;s segregation model:</p><ul><li>Agents belong to one of two groups (0 or 1).</li><li>The agents live in a two-dimensional Moore grid (8 neighbors per node).</li><li>If an agent is in the same group with at least three neighbors, then it is happy.</li><li>If an agent is unhappy, it keeps moving to new locations until it is happy.</li></ul><p>Schelling&#39;s model shows that even small preferences of agents to have neighbors belonging to the same group (e.g. preferring that at least 30% of neighbors to be in the same group) could lead to total segregation of neighborhoods.</p><h3 id="Defining-the-agent-type-1"><a class="docs-heading-anchor" href="#Defining-the-agent-type-1">Defining the agent type</a><a class="docs-heading-anchor-permalink" href="#Defining-the-agent-type-1" title="Permalink"></a></h3><pre><code class="language-julia">using Agents

mutable struct SchellingAgent &lt;: AbstractAgent
  id::Int # The identifier number of the agent
  pos::Tuple{Int,Int} # The x, y location of the agent
  mood::Bool # whether the agent is happy in its node. (true = happy)
  group::Int # The group of the agent,
             # determines mood as it interacts with neighbors
end</code></pre><p>Notice that the position of this Agent type is a <code>Tuple{Int,Int}</code> because we will use a grid <code>Space</code>.</p><p>We added two more fields for this model, namely a <code>mood</code> field which will store <code>true</code> for a happy agent and <code>false</code> for an unhappy one, and an <code>group</code> field which stores <code>0</code> or <code>1</code> representing two groups.</p><h3 id="Creating-a-space-1"><a class="docs-heading-anchor" href="#Creating-a-space-1">Creating a space</a><a class="docs-heading-anchor-permalink" href="#Creating-a-space-1" title="Permalink"></a></h3><p>For this example, we will be using a Moore 2D grid, e.g.</p><pre><code class="language-julia">space = Space((10,10), moore = true)</code></pre><pre><code class="language-none">GridSpace with 100 nodes and 342 edges</code></pre><h3 id="Creating-an-ABM-1"><a class="docs-heading-anchor" href="#Creating-an-ABM-1">Creating an ABM</a><a class="docs-heading-anchor-permalink" href="#Creating-an-ABM-1" title="Permalink"></a></h3><p>To make our model we follow the instructions of <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>. We also want to include a property <code>min_to_be_happy</code> in our model, and so we have:</p><pre><code class="language-julia">properties = Dict(:min_to_be_happy =&gt; 3)
schelling = ABM(SchellingAgent, space;
    scheduler = fastest, properties = properties)</code></pre><pre><code class="language-none">AgentBasedModel with 0 agents of type SchellingAgent
 space: GridSpace with 100 nodes and 342 edges
 scheduler: fastest
 properties: Dict(:min_to_be_happy =&gt; 3)</code></pre><p>Here we used the default scheduler (which is also the fastest one) to create the model. We could instead try to activate the agents according to their property <code>:group</code>, so that all agents of group 1 act first. We would then use the scheduler <a href="../api/#Agents.property_activation"><code>property_activation</code></a> like so:</p><pre><code class="language-">schelling2 = ABM(SchellingAgent, space;
    properties = properties, scheduler = partial_activation(:group))</code></pre><p>Notice that <code>partial_activation</code> accepts an argument and returns a function, which is why we didn&#39;t just give <code>partial_activation</code> to <code>scheduler</code>.</p><h3 id="Creating-the-ABM-through-a-function-1"><a class="docs-heading-anchor" href="#Creating-the-ABM-through-a-function-1">Creating the ABM through a function</a><a class="docs-heading-anchor-permalink" href="#Creating-the-ABM-through-a-function-1" title="Permalink"></a></h3><p>Here we put the model instantiation in a function so that it will be easy to recreate the model and change its parameters.</p><p>In addition, inside this function, we populate the model with some agents. We also change the scheduler to <a href="../api/#Agents.random_activation"><code>random_activation</code></a>. Because the function is defined based on keywords, it will be of further use in <a href="../api/#Agents.paramscan"><code>paramscan</code></a> below.</p><pre><code class="language-julia">function initialize(;numagents=320, griddims=(20, 20), min_to_be_happy=3)
    space = Space(griddims, moore = true) # make a Moore grid
    properties = Dict(:min_to_be_happy =&gt; 3)
    model = ABM(SchellingAgent, space; properties=properties, scheduler = random_activation)
    # populate the model with agents, adding equal amount of the two types of agents
    # at random positions in the model
    for n in 1:numagents
        agent = SchellingAgent(n, (1,1), false, n &lt; numagents/2 ? 1 : 2)
        add_agent_single!(agent, model)
    end
    return model
end</code></pre><pre><code class="language-none">initialize (generic function with 1 method)</code></pre><p>Notice that the position that an agent is initialized does not matter. This is because it is set properly when adding an agent to the model.</p><h3 id="Defining-a-step-function-1"><a class="docs-heading-anchor" href="#Defining-a-step-function-1">Defining a step function</a><a class="docs-heading-anchor-permalink" href="#Defining-a-step-function-1" title="Permalink"></a></h3><p>Finally, we define a <em>step</em> function to determine what happens to an agent when activated.</p><pre><code class="language-julia">function agent_step!(agent, model)
    agent.mood == true &amp;&amp; return # do nothing if already happy
    minhappy = model.properties[:min_to_be_happy]
    neighbor_cells = node_neighbors(agent, model)
    count_neighbors_same_group = 0
    # For each neighbor, get group and compare to current agent&#39;s group
    # and increment count_neighbors_same_group as appropriately.
    for neighbor_cell in neighbor_cells
        node_contents = get_node_contents(neighbor_cell, model)
        # Skip iteration if the node is empty.
        length(node_contents) == 0 &amp;&amp; continue
        # Otherwise, get the first agent in the node...
        agent_id = node_contents[1]
        # ...and increment count_neighbors_same_group if the neighbor&#39;s group is
        # the same.
        neighbor_agent_group = model.agents[agent_id].group
        if neighbor_agent_group == agent.group
            count_neighbors_same_group += 1
        end
    end
    # After counting the neighbors, decide whether or not to move the agent.
    # If count_neighbors_same_group is at least the min_to_be_happy, set the
    # mood to true. Otherwise, move the agent to a random node.
    if count_neighbors_same_group ≥ minhappy
        agent.mood = true
    else
        move_agent_single!(agent, model)
    end
    return
end</code></pre><pre><code class="language-none">agent_step! (generic function with 1 method)</code></pre><p>For the purpose of this implementation of Schelling&#39;s segregation model, we only need an agent step function.</p><p>For defining <code>agent_step!</code> we used some of the built-in functions of Agents.jl, such as <a href="../api/#Agents.node_neighbors"><code>node_neighbors</code></a> that returns the neighboring nodes of the node on which the agent resides, <a href="../api/#Agents.get_node_contents"><code>get_node_contents</code></a> that returns the IDs of the agents on a given node, and <a href="../api/#Agents.move_agent_single!"><code>move_agent_single!</code></a> which moves agents to random empty nodes on the grid. A full list of built-in functions and their explanations are available in the <a href="../api/#API-1">API</a> page.</p><h3 id="Running-the-model-1"><a class="docs-heading-anchor" href="#Running-the-model-1">Running the model</a><a class="docs-heading-anchor-permalink" href="#Running-the-model-1" title="Permalink"></a></h3><pre><code class="language-"># initialize the model with 370 agents on a 20 by 20 grid.
model = initialize()
step!(model, agent_step!)     # run the model one step
step!(model, agent_step!, 3)  # run the model 3 steps.</code></pre><h3 id="Running-the-model-and-collecting-data-1"><a class="docs-heading-anchor" href="#Running-the-model-and-collecting-data-1">Running the model and collecting data</a><a class="docs-heading-anchor-permalink" href="#Running-the-model-and-collecting-data-1" title="Permalink"></a></h3><p>We can use the same <a href="#Agents.step!"><code>step!</code></a> function with more arguments to run multiple steps and collect values of our desired fields from every agent and put these data in a <code>DataFrame</code> object.</p><pre><code class="language-julia">model = initialize()
# An array of Symbols for the agent fields that are to be collected.
properties = [:pos, :mood, :group]
# Specifies at which steps data should be collected.
n = 5  # number of time steps to run the simulation
when = 1:n  # At which steps to collect data
# Use the step function to run the model and collect data into a DataFrame.
data = step!(model, agent_step!, n, properties, when=when)
data[1:10, :] # print only a few rows</code></pre><table class="data-frame"><thead><tr><th></th><th>id</th><th>pos</th><th>mood</th><th>group</th><th>step</th></tr><tr><th></th><th>Int64</th><th>Tuple…</th><th>Bool</th><th>Int64</th><th>Int64</th></tr></thead><tbody><p>10 rows × 5 columns</p><tr><th>1</th><td>1</td><td>(14, 5)</td><td>0</td><td>2</td><td>0</td></tr><tr><th>2</th><td>2</td><td>(1, 20)</td><td>0</td><td>2</td><td>0</td></tr><tr><th>3</th><td>3</td><td>(3, 17)</td><td>0</td><td>1</td><td>0</td></tr><tr><th>4</th><td>4</td><td>(2, 11)</td><td>0</td><td>1</td><td>0</td></tr><tr><th>5</th><td>5</td><td>(4, 15)</td><td>0</td><td>1</td><td>0</td></tr><tr><th>6</th><td>6</td><td>(18, 18)</td><td>0</td><td>2</td><td>0</td></tr><tr><th>7</th><td>7</td><td>(9, 10)</td><td>0</td><td>2</td><td>0</td></tr><tr><th>8</th><td>8</td><td>(15, 2)</td><td>0</td><td>1</td><td>0</td></tr><tr><th>9</th><td>9</td><td>(9, 14)</td><td>0</td><td>1</td><td>0</td></tr><tr><th>10</th><td>10</td><td>(8, 4)</td><td>0</td><td>2</td><td>0</td></tr></tbody></table><p><code>properties</code> is an array of <a href="https://pkg.julialang.org/docs/julia/THl1k/1.1.1/manual/metaprogramming.html#Symbols-1"><code>Symbols</code></a> for the agent fields that we want to collect. <code>when</code> specifies at which steps data should be collected.</p><p>With the above <code>properties</code> vector, we collected all agents data. We can instead only collected aggregated data. For example, let&#39;s only get the number of happy individuals:</p><pre><code class="language-julia">model = initialize(numagents=370, griddims=(20,20), min_to_be_happy=3);
properties = Dict(:mood =&gt; [sum])
n = 5; when = 1:n
data = step!(model, agent_step!, 5, properties, when=when)</code></pre><table class="data-frame"><thead><tr><th></th><th>step</th><th>sum(mood)</th></tr><tr><th></th><th>Int64</th><th>Int64</th></tr></thead><tbody><p>6 rows × 2 columns</p><tr><th>1</th><td>0</td><td>0</td></tr><tr><th>2</th><td>1</td><td>280</td></tr><tr><th>3</th><td>2</td><td>334</td></tr><tr><th>4</th><td>3</td><td>353</td></tr><tr><th>5</th><td>4</td><td>362</td></tr><tr><th>6</th><td>5</td><td>364</td></tr></tbody></table><p>In the <code>Examples</code> pages there are more realistic examples with meaningful data processing steps.</p><h3 id="Visualizing-the-data-1"><a class="docs-heading-anchor" href="#Visualizing-the-data-1">Visualizing the data</a><a class="docs-heading-anchor-permalink" href="#Visualizing-the-data-1" title="Permalink"></a></h3><p>We can use the <code>plot2D</code> function to plot the distribution of agents on a 2D grid at every generation (Fig. 1):</p><pre><code class="language-julia"># Use the plot2D function from AgentsPlots.jl to plot distribution of agents at any step.
using AgentsPlots

for i in 1:2
  p = plot2D(data, :group, t=i, nodesize=10)
end</code></pre><p>The first argument of the <code>plot2D</code> is the output data. The second argument is the column name in <code>data</code> that has the categories of each agent, which is <code>:group</code> in this case. <code>nodesize</code> determines the size of cells in the plot.</p><p>Custom plots can be easily made with <a href="https://github.com/queryverse/DataVoyager.jl"><code>DataVoyager</code></a> because the outputs of simulations are always as a <code>DataFrame</code> object.</p><pre><code class="language-julia">using DataVoyager
v = Voyager(data)</code></pre><h3 id="Replicates-and-parallel-computing-1"><a class="docs-heading-anchor" href="#Replicates-and-parallel-computing-1">Replicates and parallel computing</a><a class="docs-heading-anchor-permalink" href="#Replicates-and-parallel-computing-1" title="Permalink"></a></h3><p>We can run replicates of a simulation and collect all of them in a single <code>DataFrame</code>. To that end, we only need to specify the correct arguments to the <code>step!</code> function:</p><pre><code class="language-julia">model = initialize(numagents=370, griddims=(20,20), min_to_be_happy=3);
data = step!(model, agent_step!, 5, properties, when=when, replicates=5)</code></pre><table class="data-frame"><thead><tr><th></th><th>step</th><th>sum(mood)</th><th>replicate</th></tr><tr><th></th><th>Int64</th><th>Int64</th><th>Int64</th></tr></thead><tbody><p>30 rows × 3 columns</p><tr><th>1</th><td>0</td><td>0</td><td>1</td></tr><tr><th>2</th><td>1</td><td>272</td><td>1</td></tr><tr><th>3</th><td>2</td><td>319</td><td>1</td></tr><tr><th>4</th><td>3</td><td>348</td><td>1</td></tr><tr><th>5</th><td>4</td><td>356</td><td>1</td></tr><tr><th>6</th><td>5</td><td>358</td><td>1</td></tr><tr><th>7</th><td>0</td><td>0</td><td>2</td></tr><tr><th>8</th><td>1</td><td>273</td><td>2</td></tr><tr><th>9</th><td>2</td><td>332</td><td>2</td></tr><tr><th>10</th><td>3</td><td>352</td><td>2</td></tr><tr><th>11</th><td>4</td><td>362</td><td>2</td></tr><tr><th>12</th><td>5</td><td>365</td><td>2</td></tr><tr><th>13</th><td>0</td><td>0</td><td>3</td></tr><tr><th>14</th><td>1</td><td>271</td><td>3</td></tr><tr><th>15</th><td>2</td><td>324</td><td>3</td></tr><tr><th>16</th><td>3</td><td>346</td><td>3</td></tr><tr><th>17</th><td>4</td><td>357</td><td>3</td></tr><tr><th>18</th><td>5</td><td>364</td><td>3</td></tr><tr><th>19</th><td>0</td><td>0</td><td>4</td></tr><tr><th>20</th><td>1</td><td>273</td><td>4</td></tr><tr><th>21</th><td>2</td><td>335</td><td>4</td></tr><tr><th>22</th><td>3</td><td>358</td><td>4</td></tr><tr><th>23</th><td>4</td><td>364</td><td>4</td></tr><tr><th>24</th><td>5</td><td>366</td><td>4</td></tr><tr><th>25</th><td>0</td><td>0</td><td>5</td></tr><tr><th>26</th><td>1</td><td>265</td><td>5</td></tr><tr><th>27</th><td>2</td><td>332</td><td>5</td></tr><tr><th>28</th><td>3</td><td>353</td><td>5</td></tr><tr><th>29</th><td>4</td><td>360</td><td>5</td></tr><tr><th>30</th><td>5</td><td>363</td><td>5</td></tr></tbody></table><p>It is possible to run the replicates in parallel. For that, we should start julia with <code>julia -p n</code> where is the number of processing cores. Alternatively, we can define the number of cores from within a Julia session:</p><pre><code class="language-julia">using Distributed
addprocs(4)</code></pre><p>Next, we should import <code>Agents</code> on all cores: <code>@everywhere using Agents</code>.</p><p>Finally, we can tell the <code>step!</code> function to run replicates in parallel:</p><pre><code class="language-julia">data = step!(model, agent_step!, 2, properties,
             when=when, replicates=5, parallel=true)</code></pre><h3 id="Scanning-parameter-ranges-1"><a class="docs-heading-anchor" href="#Scanning-parameter-ranges-1">Scanning parameter ranges</a><a class="docs-heading-anchor-permalink" href="#Scanning-parameter-ranges-1" title="Permalink"></a></h3><p>We often are interested in the effect of different parameters on the behavior of an agent-based model. <code>Agents.jl</code> provides the function <a href="../api/#Agents.paramscan"><code>paramscan</code></a> to automatically explore the effect of different parameter values.</p><p>We have already defined our model initialization function as <code>initialize</code>. We now also define a processing function, that returns the percentage of happy agents:</p><pre><code class="language-julia">happyperc(moods) = count(x -&gt; x == true, moods)/length(moods)</code></pre><pre><code class="language-none">happyperc (generic function with 1 method)</code></pre><pre><code class="language-julia">properties= Dict(:mood=&gt;[happyperc])
parameters = Dict(:min_to_be_happy=&gt;collect(2:5), :numagents=&gt;[200,300], :griddims=&gt;(20,20))

data = paramscan(parameters, initialize;
       properties=properties, n = 3, agent_step! = agent_step!)</code></pre><table class="data-frame"><thead><tr><th></th><th>happyperc(mood)</th><th>step</th><th>min_to_be_happy</th><th>numagents</th></tr><tr><th></th><th>Float64</th><th>Int64</th><th>Int64</th><th>Int64</th></tr></thead><tbody><p>32 rows × 4 columns</p><tr><th>1</th><td>0.0</td><td>0</td><td>5</td><td>300</td></tr><tr><th>2</th><td>0.636667</td><td>1</td><td>5</td><td>300</td></tr><tr><th>3</th><td>0.843333</td><td>2</td><td>5</td><td>300</td></tr><tr><th>4</th><td>0.92</td><td>3</td><td>5</td><td>300</td></tr><tr><th>5</th><td>0.0</td><td>0</td><td>4</td><td>300</td></tr><tr><th>6</th><td>0.596667</td><td>1</td><td>4</td><td>300</td></tr><tr><th>7</th><td>0.803333</td><td>2</td><td>4</td><td>300</td></tr><tr><th>8</th><td>0.873333</td><td>3</td><td>4</td><td>300</td></tr><tr><th>9</th><td>0.0</td><td>0</td><td>3</td><td>300</td></tr><tr><th>10</th><td>0.593333</td><td>1</td><td>3</td><td>300</td></tr><tr><th>11</th><td>0.846667</td><td>2</td><td>3</td><td>300</td></tr><tr><th>12</th><td>0.926667</td><td>3</td><td>3</td><td>300</td></tr><tr><th>13</th><td>0.0</td><td>0</td><td>2</td><td>300</td></tr><tr><th>14</th><td>0.61</td><td>1</td><td>2</td><td>300</td></tr><tr><th>15</th><td>0.81</td><td>2</td><td>2</td><td>300</td></tr><tr><th>16</th><td>0.886667</td><td>3</td><td>2</td><td>300</td></tr><tr><th>17</th><td>0.0</td><td>0</td><td>5</td><td>200</td></tr><tr><th>18</th><td>0.405</td><td>1</td><td>5</td><td>200</td></tr><tr><th>19</th><td>0.655</td><td>2</td><td>5</td><td>200</td></tr><tr><th>20</th><td>0.72</td><td>3</td><td>5</td><td>200</td></tr><tr><th>21</th><td>0.0</td><td>0</td><td>4</td><td>200</td></tr><tr><th>22</th><td>0.33</td><td>1</td><td>4</td><td>200</td></tr><tr><th>23</th><td>0.56</td><td>2</td><td>4</td><td>200</td></tr><tr><th>24</th><td>0.695</td><td>3</td><td>4</td><td>200</td></tr><tr><th>25</th><td>0.0</td><td>0</td><td>3</td><td>200</td></tr><tr><th>26</th><td>0.38</td><td>1</td><td>3</td><td>200</td></tr><tr><th>27</th><td>0.595</td><td>2</td><td>3</td><td>200</td></tr><tr><th>28</th><td>0.715</td><td>3</td><td>3</td><td>200</td></tr><tr><th>29</th><td>0.0</td><td>0</td><td>2</td><td>200</td></tr><tr><th>30</th><td>0.305</td><td>1</td><td>2</td><td>200</td></tr><tr><th>31</th><td>0.56</td><td>2</td><td>2</td><td>200</td></tr><tr><th>32</th><td>0.72</td><td>3</td><td>2</td><td>200</td></tr></tbody></table><p><code>paramscan</code> allows running replicates per parameter setting:</p><pre><code class="language-julia">data = paramscan(parameters, initialize;
              properties=properties, n = 3, agent_step! = agent_step!, replicates=3)</code></pre><table class="data-frame"><thead><tr><th></th><th>happyperc(mood)</th><th>step</th><th>replicate</th><th>min_to_be_happy</th><th>numagents</th></tr><tr><th></th><th>Float64</th><th>Int64</th><th>Int64</th><th>Int64</th><th>Int64</th></tr></thead><tbody><p>96 rows × 5 columns</p><tr><th>1</th><td>0.0</td><td>0</td><td>1</td><td>5</td><td>300</td></tr><tr><th>2</th><td>0.57</td><td>1</td><td>1</td><td>5</td><td>300</td></tr><tr><th>3</th><td>0.823333</td><td>2</td><td>1</td><td>5</td><td>300</td></tr><tr><th>4</th><td>0.893333</td><td>3</td><td>1</td><td>5</td><td>300</td></tr><tr><th>5</th><td>0.0</td><td>0</td><td>2</td><td>5</td><td>300</td></tr><tr><th>6</th><td>0.57</td><td>1</td><td>2</td><td>5</td><td>300</td></tr><tr><th>7</th><td>0.813333</td><td>2</td><td>2</td><td>5</td><td>300</td></tr><tr><th>8</th><td>0.89</td><td>3</td><td>2</td><td>5</td><td>300</td></tr><tr><th>9</th><td>0.0</td><td>0</td><td>3</td><td>5</td><td>300</td></tr><tr><th>10</th><td>0.553333</td><td>1</td><td>3</td><td>5</td><td>300</td></tr><tr><th>11</th><td>0.816667</td><td>2</td><td>3</td><td>5</td><td>300</td></tr><tr><th>12</th><td>0.92</td><td>3</td><td>3</td><td>5</td><td>300</td></tr><tr><th>13</th><td>0.0</td><td>0</td><td>1</td><td>4</td><td>300</td></tr><tr><th>14</th><td>0.59</td><td>1</td><td>1</td><td>4</td><td>300</td></tr><tr><th>15</th><td>0.833333</td><td>2</td><td>1</td><td>4</td><td>300</td></tr><tr><th>16</th><td>0.91</td><td>3</td><td>1</td><td>4</td><td>300</td></tr><tr><th>17</th><td>0.0</td><td>0</td><td>2</td><td>4</td><td>300</td></tr><tr><th>18</th><td>0.573333</td><td>1</td><td>2</td><td>4</td><td>300</td></tr><tr><th>19</th><td>0.806667</td><td>2</td><td>2</td><td>4</td><td>300</td></tr><tr><th>20</th><td>0.92</td><td>3</td><td>2</td><td>4</td><td>300</td></tr><tr><th>21</th><td>0.0</td><td>0</td><td>3</td><td>4</td><td>300</td></tr><tr><th>22</th><td>0.613333</td><td>1</td><td>3</td><td>4</td><td>300</td></tr><tr><th>23</th><td>0.856667</td><td>2</td><td>3</td><td>4</td><td>300</td></tr><tr><th>24</th><td>0.926667</td><td>3</td><td>3</td><td>4</td><td>300</td></tr><tr><th>25</th><td>0.0</td><td>0</td><td>1</td><td>3</td><td>300</td></tr><tr><th>26</th><td>0.62</td><td>1</td><td>1</td><td>3</td><td>300</td></tr><tr><th>27</th><td>0.81</td><td>2</td><td>1</td><td>3</td><td>300</td></tr><tr><th>28</th><td>0.91</td><td>3</td><td>1</td><td>3</td><td>300</td></tr><tr><th>29</th><td>0.0</td><td>0</td><td>2</td><td>3</td><td>300</td></tr><tr><th>30</th><td>0.646667</td><td>1</td><td>2</td><td>3</td><td>300</td></tr><tr><th>31</th><td>0.82</td><td>2</td><td>2</td><td>3</td><td>300</td></tr><tr><th>32</th><td>0.9</td><td>3</td><td>2</td><td>3</td><td>300</td></tr><tr><th>33</th><td>0.0</td><td>0</td><td>3</td><td>3</td><td>300</td></tr><tr><th>34</th><td>0.613333</td><td>1</td><td>3</td><td>3</td><td>300</td></tr><tr><th>35</th><td>0.823333</td><td>2</td><td>3</td><td>3</td><td>300</td></tr><tr><th>36</th><td>0.92</td><td>3</td><td>3</td><td>3</td><td>300</td></tr><tr><th>37</th><td>0.0</td><td>0</td><td>1</td><td>2</td><td>300</td></tr><tr><th>38</th><td>0.646667</td><td>1</td><td>1</td><td>2</td><td>300</td></tr><tr><th>39</th><td>0.84</td><td>2</td><td>1</td><td>2</td><td>300</td></tr><tr><th>40</th><td>0.913333</td><td>3</td><td>1</td><td>2</td><td>300</td></tr><tr><th>41</th><td>0.0</td><td>0</td><td>2</td><td>2</td><td>300</td></tr><tr><th>42</th><td>0.626667</td><td>1</td><td>2</td><td>2</td><td>300</td></tr><tr><th>43</th><td>0.82</td><td>2</td><td>2</td><td>2</td><td>300</td></tr><tr><th>44</th><td>0.9</td><td>3</td><td>2</td><td>2</td><td>300</td></tr><tr><th>45</th><td>0.0</td><td>0</td><td>3</td><td>2</td><td>300</td></tr><tr><th>46</th><td>0.643333</td><td>1</td><td>3</td><td>2</td><td>300</td></tr><tr><th>47</th><td>0.843333</td><td>2</td><td>3</td><td>2</td><td>300</td></tr><tr><th>48</th><td>0.94</td><td>3</td><td>3</td><td>2</td><td>300</td></tr><tr><th>49</th><td>0.0</td><td>0</td><td>1</td><td>5</td><td>200</td></tr><tr><th>50</th><td>0.345</td><td>1</td><td>1</td><td>5</td><td>200</td></tr><tr><th>51</th><td>0.6</td><td>2</td><td>1</td><td>5</td><td>200</td></tr><tr><th>52</th><td>0.725</td><td>3</td><td>1</td><td>5</td><td>200</td></tr><tr><th>53</th><td>0.0</td><td>0</td><td>2</td><td>5</td><td>200</td></tr><tr><th>54</th><td>0.36</td><td>1</td><td>2</td><td>5</td><td>200</td></tr><tr><th>55</th><td>0.59</td><td>2</td><td>2</td><td>5</td><td>200</td></tr><tr><th>56</th><td>0.71</td><td>3</td><td>2</td><td>5</td><td>200</td></tr><tr><th>57</th><td>0.0</td><td>0</td><td>3</td><td>5</td><td>200</td></tr><tr><th>58</th><td>0.325</td><td>1</td><td>3</td><td>5</td><td>200</td></tr><tr><th>59</th><td>0.525</td><td>2</td><td>3</td><td>5</td><td>200</td></tr><tr><th>60</th><td>0.665</td><td>3</td><td>3</td><td>5</td><td>200</td></tr><tr><th>61</th><td>0.0</td><td>0</td><td>1</td><td>4</td><td>200</td></tr><tr><th>62</th><td>0.345</td><td>1</td><td>1</td><td>4</td><td>200</td></tr><tr><th>63</th><td>0.565</td><td>2</td><td>1</td><td>4</td><td>200</td></tr><tr><th>64</th><td>0.68</td><td>3</td><td>1</td><td>4</td><td>200</td></tr><tr><th>65</th><td>0.0</td><td>0</td><td>2</td><td>4</td><td>200</td></tr><tr><th>66</th><td>0.39</td><td>1</td><td>2</td><td>4</td><td>200</td></tr><tr><th>67</th><td>0.63</td><td>2</td><td>2</td><td>4</td><td>200</td></tr><tr><th>68</th><td>0.74</td><td>3</td><td>2</td><td>4</td><td>200</td></tr><tr><th>69</th><td>0.0</td><td>0</td><td>3</td><td>4</td><td>200</td></tr><tr><th>70</th><td>0.34</td><td>1</td><td>3</td><td>4</td><td>200</td></tr><tr><th>71</th><td>0.52</td><td>2</td><td>3</td><td>4</td><td>200</td></tr><tr><th>72</th><td>0.725</td><td>3</td><td>3</td><td>4</td><td>200</td></tr><tr><th>73</th><td>0.0</td><td>0</td><td>1</td><td>3</td><td>200</td></tr><tr><th>74</th><td>0.355</td><td>1</td><td>1</td><td>3</td><td>200</td></tr><tr><th>75</th><td>0.605</td><td>2</td><td>1</td><td>3</td><td>200</td></tr><tr><th>76</th><td>0.715</td><td>3</td><td>1</td><td>3</td><td>200</td></tr><tr><th>77</th><td>0.0</td><td>0</td><td>2</td><td>3</td><td>200</td></tr><tr><th>78</th><td>0.36</td><td>1</td><td>2</td><td>3</td><td>200</td></tr><tr><th>79</th><td>0.555</td><td>2</td><td>2</td><td>3</td><td>200</td></tr><tr><th>80</th><td>0.705</td><td>3</td><td>2</td><td>3</td><td>200</td></tr><tr><th>81</th><td>0.0</td><td>0</td><td>3</td><td>3</td><td>200</td></tr><tr><th>82</th><td>0.37</td><td>1</td><td>3</td><td>3</td><td>200</td></tr><tr><th>83</th><td>0.61</td><td>2</td><td>3</td><td>3</td><td>200</td></tr><tr><th>84</th><td>0.745</td><td>3</td><td>3</td><td>3</td><td>200</td></tr><tr><th>85</th><td>0.0</td><td>0</td><td>1</td><td>2</td><td>200</td></tr><tr><th>86</th><td>0.26</td><td>1</td><td>1</td><td>2</td><td>200</td></tr><tr><th>87</th><td>0.505</td><td>2</td><td>1</td><td>2</td><td>200</td></tr><tr><th>88</th><td>0.665</td><td>3</td><td>1</td><td>2</td><td>200</td></tr><tr><th>89</th><td>0.0</td><td>0</td><td>2</td><td>2</td><td>200</td></tr><tr><th>90</th><td>0.315</td><td>1</td><td>2</td><td>2</td><td>200</td></tr><tr><th>91</th><td>0.605</td><td>2</td><td>2</td><td>2</td><td>200</td></tr><tr><th>92</th><td>0.74</td><td>3</td><td>2</td><td>2</td><td>200</td></tr><tr><th>93</th><td>0.0</td><td>0</td><td>3</td><td>2</td><td>200</td></tr><tr><th>94</th><td>0.28</td><td>1</td><td>3</td><td>2</td><td>200</td></tr><tr><th>95</th><td>0.495</td><td>2</td><td>3</td><td>2</td><td>200</td></tr><tr><th>96</th><td>0.64</td><td>3</td><td>3</td><td>2</td><td>200</td></tr></tbody></table><p>We can combine all replicates with an aggregating function, such as mean, using the <code>aggregate</code> function from the <code>DataFrames</code> package:</p><pre><code class="language-julia">using DataFrames: Not, select!
using Statistics: mean
data_mean = Agents.aggregate(data, [:step, :min_to_be_happy, :numagents],  mean);
select!(data_mean, Not(:replicate_mean))</code></pre><table class="data-frame"><thead><tr><th></th><th>step</th><th>min_to_be_happy</th><th>numagents</th><th>happyperc(mood)_mean</th></tr><tr><th></th><th>Int64</th><th>Int64</th><th>Int64</th><th>Float64</th></tr></thead><tbody><p>32 rows × 4 columns</p><tr><th>1</th><td>0</td><td>5</td><td>300</td><td>0.0</td></tr><tr><th>2</th><td>1</td><td>5</td><td>300</td><td>0.564444</td></tr><tr><th>3</th><td>2</td><td>5</td><td>300</td><td>0.817778</td></tr><tr><th>4</th><td>3</td><td>5</td><td>300</td><td>0.901111</td></tr><tr><th>5</th><td>0</td><td>4</td><td>300</td><td>0.0</td></tr><tr><th>6</th><td>1</td><td>4</td><td>300</td><td>0.592222</td></tr><tr><th>7</th><td>2</td><td>4</td><td>300</td><td>0.832222</td></tr><tr><th>8</th><td>3</td><td>4</td><td>300</td><td>0.918889</td></tr><tr><th>9</th><td>0</td><td>3</td><td>300</td><td>0.0</td></tr><tr><th>10</th><td>1</td><td>3</td><td>300</td><td>0.626667</td></tr><tr><th>11</th><td>2</td><td>3</td><td>300</td><td>0.817778</td></tr><tr><th>12</th><td>3</td><td>3</td><td>300</td><td>0.91</td></tr><tr><th>13</th><td>0</td><td>2</td><td>300</td><td>0.0</td></tr><tr><th>14</th><td>1</td><td>2</td><td>300</td><td>0.638889</td></tr><tr><th>15</th><td>2</td><td>2</td><td>300</td><td>0.834444</td></tr><tr><th>16</th><td>3</td><td>2</td><td>300</td><td>0.917778</td></tr><tr><th>17</th><td>0</td><td>5</td><td>200</td><td>0.0</td></tr><tr><th>18</th><td>1</td><td>5</td><td>200</td><td>0.343333</td></tr><tr><th>19</th><td>2</td><td>5</td><td>200</td><td>0.571667</td></tr><tr><th>20</th><td>3</td><td>5</td><td>200</td><td>0.7</td></tr><tr><th>21</th><td>0</td><td>4</td><td>200</td><td>0.0</td></tr><tr><th>22</th><td>1</td><td>4</td><td>200</td><td>0.358333</td></tr><tr><th>23</th><td>2</td><td>4</td><td>200</td><td>0.571667</td></tr><tr><th>24</th><td>3</td><td>4</td><td>200</td><td>0.715</td></tr><tr><th>25</th><td>0</td><td>3</td><td>200</td><td>0.0</td></tr><tr><th>26</th><td>1</td><td>3</td><td>200</td><td>0.361667</td></tr><tr><th>27</th><td>2</td><td>3</td><td>200</td><td>0.59</td></tr><tr><th>28</th><td>3</td><td>3</td><td>200</td><td>0.721667</td></tr><tr><th>29</th><td>0</td><td>2</td><td>200</td><td>0.0</td></tr><tr><th>30</th><td>1</td><td>2</td><td>200</td><td>0.285</td></tr><tr><th>31</th><td>2</td><td>2</td><td>200</td><td>0.535</td></tr><tr><th>32</th><td>3</td><td>2</td><td>200</td><td>0.681667</td></tr></tbody></table><p>Note that the second argument takes the column names on which to split the data, i.e., it denotes which columns should not be aggregated. It should include the <code>:step</code> column and any parameter that changes among simulations. But it should not include the <code>:replicate</code> column. So in principle wha we are doing here is simply averaging our result across the replicates.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../api/">API »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 16 December 2019 23:19">Monday 16 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
