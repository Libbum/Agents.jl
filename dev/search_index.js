var documenterSearchIndex = {"docs":
[{"location":"mesa/#Agents.jl-vs-Mesa:-speed-comparison-1","page":"Comparison against Mesa (Python)","title":"Agents.jl vs Mesa: speed comparison","text":"","category":"section"},{"location":"mesa/#","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"Julia code can run much faster than Python. And since Agents.jl is a minimal framework, an agent-based model written in Julia and using Agents.jl can be much faster than the same algorithm written in Python and using the Mesa package. Furthermore, Agents.jl has a considerably simpler API which reduces the learning curve. Mesa, on the other hand, is much stronger in visualizing the simulations.","category":"page"},{"location":"mesa/#","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"Here is a benchmark of a version of the forest fire model implemented both in Agents.jl and in Mesa. This version of the model is simpler than the one in the examples folder. The Python implementation is taken from Mesa's Github page. The Julia implementation follows the same logic as the Python implementation. The code for both implementations is in the test/benchmark/mesa folder on Agents.jl's Github page.","category":"page"},{"location":"mesa/#","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"Briefly, the model has two parameters: grid size and forest density. It initially plants trees on the grid given the density. Next, it sets trees on one edge of the forest on fire. During each iteration, neighboring trees to a tree on fire catch fire and those trees already on fire burn down. There is no growth of trees.","category":"page"},{"location":"mesa/#","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"Figure below shows the time it takes for 100 iterations of a \"forest fire\" model with a density of 0.6 in Mesa and Agents.jl. The x-axis of the figure is different grid sizes. The model implemented in Agents.jl is up to more than 13 times faster than the model implemented in Mesa.","category":"page"},{"location":"mesa/#","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"(Image: Speed comparison of a version of \"forest fire\" model in Agents.jl vs Mesa.)","category":"page"},{"location":"mesa/#","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"Here are the relative numbers: (Image: Relative speed comparison of a version of \"forest fire\" model in Agents.jl vs Mesa.)","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/sir.jl\"","category":"page"},{"location":"examples/sir/#SIR-model-for-the-spread-of-COVID-19-1","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"","category":"section"},{"location":"examples/sir/#SIR-model-1","page":"SIR model for the spread of COVID-19","title":"SIR model","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"SIR model tracks the ratio of Susceptible, Infected, and Recovered individuals within a population. Here we add one more category of individuals: those who are infected, but do not know it. Transmission rate of infected and diagnosed is lower than infected and undetected. We also allow a fraction of recovered individuals to catch the disease again, meaning that recovering the disease does not bring full immunity.","category":"page"},{"location":"examples/sir/#Model-parameters-1","page":"SIR model for the spread of COVID-19","title":"Model parameters","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Here are the model parameters, some of which have default values.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Ns: a vector of population sizes per city. The amount of cities is just C=length(Ns).\nβ_und: a vector for transmission probabilities β of the infected but undetected per city. Transmission probability is how many susceptible are infected per day by an infected individual. If social distancing is practiced, this number increases.\nβ_det: an array for transmission probabilities β of the infected and detected per city. If hospitals are full, this number increases.\ninfection_period = 30: how many days before a person dies or recovers.\ndetection_time = 14: how many days before an infected person is detected.\ndeath_rate = 0.02: the probability that the individual will die after the infection_period.\nreinfection_probability = 0.05: The probability that a recovered person can get infected again.\nmigration_rates: A matrix of migration probability per individual per day from one city to another.\nIs = [zeros(C-1)..., 1]: An array for initial number of infected but undetected people per city. This starts as only one infected individual in the last city.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Notice that all Ns, β, Is need to have the same length, as they are numbers for each city. We've tried to add values to the infection parameters similar to the ones you would hear on the news about COVID-19.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"The good thing with Agent based models is that you could easily extend the model we implement here to also include age as the agent's property. This makes ABMs flexible and suitable for research of virus spreading.","category":"page"},{"location":"examples/sir/#Making-the-model-in-Agents.jl-1","page":"SIR model for the spread of COVID-19","title":"Making the model in Agents.jl","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We start by defining the PoorSoul agent type and the ABM","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"using Agents, Random, DataFrames, LightGraphs\nusing Distributions: Poisson, DiscreteNonParametric\nusing DrWatson: @dict\nusing Plots\n\nmutable struct PoorSoul <: AbstractAgent\n  id::Int\n  pos::Int\n  days_infected::Int  # number of days since is infected\n  status::Symbol  # 1: S, 2: I, 3:R\nend\n\nfunction model_initiation(;Ns, migration_rates, β_und, β_det, infection_period = 30,\n  reinfection_probability = 0.05, detection_time = 14, death_rate = 0.02,\n  Is=[zeros(Int, length(Ns)-1)..., 1], seed = 0)\n\n  Random.seed!(seed)\n  @assert length(Ns) == length(Is) == length(β_und) == length(β_det) == size(migration_rates, 1) \"length of Ns, Is, and B, and number of rows/columns in migration_rates should be the same \"\n  @assert size(migration_rates, 1) == size(migration_rates, 2) \"migration_rates rates should be a square matrix\"\n\n  C = length(Ns)\n  # normalize migration_rates\n  migration_rates_sum = sum(migration_rates, dims=2)\n  for c in 1:C\n    migration_rates[c, :] ./= migration_rates_sum[c]\n  end\n\n  properties =\n    @dict(Ns, Is, β_und, β_det, β_det, migration_rates, infection_period,\n    infection_period, reinfection_probability, detection_time, C, death_rate)\n  space = GraphSpace(complete_digraph(C))\n  model = ABM(PoorSoul, space; properties=properties)\n\n  # Add initial individuals\n  for city in 1:C, n in 1:Ns[city]\n    ind = add_agent!(city, model, 0, :S) # Susceptible\n  end\n  # add infected individuals\n  for city in 1:C\n    inds = get_node_contents(city, model)\n    for n in 1:Is[city]\n      agent = id2agent(inds[n], model)\n      agent.status = :I # Infected\n      agent.days_infected = 1\n    end\n  end\n  return model\nend","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We will make a function that starts a model with C number of cities, and creates the other parameters automatically by attributing some random values to them. You could directly use the above constructor and specify all Ns, β, etc. but the following is convenient for this example","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"All cities are connected with each other, while it is more probable to travel from a city with small population into a city with large population.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"using LinearAlgebra: diagind\n\nfunction create_params(;C, max_travel_rate, infection_period = 30,\n    reinfection_probability = 0.05, detection_time = 14, death_rate = 0.02,\n    Is=[zeros(Int, C-1)..., 1], seed = 19\n  )\n\n  Random.seed!(seed)\n  Ns = rand(50:5000, C)\n  β_und = rand(0.3:0.02:0.6, C)\n  β_det = β_und ./ 10\n\n  Random.seed!(seed)\n  migration_rates = zeros(C, C);\n  for c in 1:C\n    for c2 in 1:C\n      migration_rates[c, c2] = (Ns[c] + Ns[c2])/Ns[c]\n    end\n  end\n  maxM = maximum(migration_rates)\n  migration_rates = (migration_rates .* max_travel_rate) ./ maxM\n  migration_rates[diagind(migration_rates)] .= 1.0\n\n  params = @dict(Ns, β_und, β_det, migration_rates, infection_period,\n    reinfection_probability, detection_time, death_rate, Is)\n\n  return params\nend\n\nparams = create_params(C=8, max_travel_rate=0.01)\nmodel = model_initiation(;params...)","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Alright, let's plot the cities as a graph to get an idea how the model \"looks like\", using the function plotabm.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"using AgentsPlots\n\nplotargs = (node_size\t= 0.2, method = :circular, linealpha = 0.4)\n\nplotabm(model; plotargs...)","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"The node size is proportional to the relative population of each city. In principle we could adjust the edge widths to be proportional with the migration rates, by doing:","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"g = model.space.graph\nedgewidthsdict = Dict()\nfor node in 1:nv(g)\n  nbs = neighbors(g, node)\n  for nb in nbs\n    edgewidthsdict[(node, nb)] = params[:migration_rates][node, nb]\n  end\nend\n\nedgewidthsf(s, d, w) = edgewidthsdict[(s, d)] * 250\n\nplotargs = merge(plotargs, (edgewidth = edgewidthsf,))\n\nplotabm(model; plotargs...)","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"In the following we will be colloring each node according to how large percentage of the population is infected. So we create a function to give to plotabm as second argument","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"infected_fraction(x) =  cgrad(:inferno)[count(a.status == :I for a in x)/length(x)]\nplotabm(model, infected_fraction; plotargs...)","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Here this shows all nodes as black, since we haven't run the model yet. Let's change that!","category":"page"},{"location":"examples/sir/#SIR-Stepping-functions-1","page":"SIR model for the spread of COVID-19","title":"SIR Stepping functions","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Now we define the functions for modelling the virus spread in time","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"function agent_step!(agent, model)\n  migrate!(agent, model)\n  transmit!(agent, model)\n  update!(agent, model)\n  recover_or_die!(agent, model)\nend\n\nfunction migrate!(agent, model)\n  nodeid = agent.pos\n  d = DiscreteNonParametric(1:model.properties[:C], model.properties[:migration_rates][nodeid, :])\n  m = rand(d)\n  if m ≠ nodeid\n    move_agent!(agent, m, model)\n  end\nend\n\nfunction transmit!(agent, model)\n  agent.status == :S && return\n  prop = model.properties\n  rate = if agent.days_infected < prop[:detection_time]\n    prop[:β_und][agent.pos]\n  else\n    prop[:β_det][agent.pos]\n  end\n\n  d = Poisson(rate)\n  n = rand(d)\n  n == 0 && return\n\n  for contactID in get_node_contents(agent, model)\n    contact = id2agent(contactID, model)\n    if contact.status == :S || (contact.status == :R && rand() ≤ prop[:reinfection_probability])\n      contact.status = :I\n      n -= 1\n      n == 0 && return\n    end\n  end\nend\n\nupdate!(agent, model) = agent.status == :I && (agent.days_infected += 1)\n\nfunction recover_or_die!(agent, model)\n  if agent.days_infected ≥ model.properties[:infection_period]\n    if rand() ≤ model.properties[:death_rate]\n      kill_agent!(agent, model)\n    else\n      agent.status = :R\n      agent.days_infected = 0\n    end\n  end\nend","category":"page"},{"location":"examples/sir/#Example-animation-1","page":"SIR model for the spread of COVID-19","title":"Example animation","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"model = model_initiation(;params...)\n\nanim = @animate for i ∈ 1:30\n  step!(model, agent_step!, 1)\n  p1 = plotabm(model, infected_fraction; plotargs...)\n  title!(p1, \"Day $(i)\")\nend\n\ngif(anim, \"covid_evolution.gif\", fps = 5);\n\nmodel","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"(Image: )","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"One can really see \"explosive growth\" in this animation. Things look quite calm for a while and then suddenly supermarkets have no toilet paper anymore!","category":"page"},{"location":"examples/sir/#Exponential-growth-1","page":"SIR model for the spread of COVID-19","title":"Exponential growth","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We now run the model and collect data. We define two useful functions for data collection:","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"infected(x) = count(i == :I for i in x)\nrecovered(x) = count(i == :R for i in x)","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"and then collect data","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"model = model_initiation(;params...)\n\ndata_to_collect = Dict(:status => [infected, recovered, length])\ndata = step!(model, agent_step!, 100, data_to_collect)\ndata[1:10, :]","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We now plot how quantities evolved in time to show the exponential growth of the virus","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"N = sum(model.properties[:Ns]) # Total initial population\nx = data.step\np = Plots.plot(x, log10.(data[:, Symbol(\"infected(status)\")]), label = \"infected\")\nplot!(p, x, log10.(data[:, Symbol(\"recovered(status)\")]), label = \"recovered\")\ndead = log10.(N .- data[:, Symbol(\"length(status)\")])\nplot!(p, x, dead, label = \"dead\")\nxlabel!(p, \"steps\")\nylabel!(p, \"log( count )\")\np","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"The exponential growth is clearly visible since the logarithm of the  number of infected increases linearly, until everyone is infected.","category":"page"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/game_of_life_2D_CA.jl\"","category":"page"},{"location":"examples/game_of_life_2D_CA/#Two-dimensional-cellular-automata-1","page":"Game of life","title":"Two-dimensional cellular automata","text":"","category":"section"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"Agents.jl provides a module (CA2D) to create and plot 2D cellular automata.","category":"page"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"using Agents\nusing AgentsPlots\nusing Agents.CA2D","category":"page"},{"location":"examples/game_of_life_2D_CA/#.-Define-the-rule-1","page":"Game of life","title":"1. Define the rule","text":"","category":"section"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"Rules of Conway's game of life: DSR (Death, Survival, Reproduction). Cells die if the number of their living neighbors are <D, survive if the number of their living neighbors are <=S, come to life if their living neighbors are as many as R.","category":"page"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"rules = (2,3,3)","category":"page"},{"location":"examples/game_of_life_2D_CA/#.-Build-the-model-1","page":"Game of life","title":"2. Build the model","text":"","category":"section"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"\"CA2D.build_model\" creates a model where all cells are by default off (\"0\")","category":"page"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"model = CA2D.build_model(rules=rules, dims=(100, 100), Moore=true)","category":"page"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"Let's make some random cells on","category":"page"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"for i in 1:nv(model)\n  if rand() < 0.1\n    model.agents[i].status=\"1\"\n  end\nend","category":"page"},{"location":"examples/game_of_life_2D_CA/#.-Animate-the-model-1","page":"Game of life","title":"3. Animate the model","text":"","category":"section"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"Animations of 2D Cellular Automata are done through the following syntax: (plot_CA2Dgif is a function from AgentsPlots that creates the animation)","category":"page"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"runs = 10\nanim = CA2D.ca_run(model, runs, plot_CA2Dgif);\nnothing #hide","category":"page"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"We can now save the animation to a gif.","category":"page"},{"location":"examples/game_of_life_2D_CA/#","page":"Game of life","title":"Game of life","text":"AgentsPlots.gif(anim, \"game_of_life.gif\")","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/schelling.jl\"","category":"page"},{"location":"examples/schelling/#Schelling's-segregation-model-1","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"In this introductory example we demonstrate Agents.jl's architecture and features through building the following definition of Schelling's segregation model:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Agents belong to one of two groups (0 or 1).\nThe agents live in a two-dimensional Moore grid (8 neighbors per node).\nIf an agent is in the same group with at least three neighbors, then it is happy.\nIf an agent is unhappy, it keeps moving to new locations until it is happy.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Schelling's model shows that even small preferences of agents to have neighbors belonging to the same group (e.g. preferring that at least 30% of neighbors to be in the same group) could lead to total segregation of neighborhoods.","category":"page"},{"location":"examples/schelling/#Defining-the-agent-type-1","page":"Schelling's segregation model","title":"Defining the agent type","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using Agents\n\nmutable struct SchellingAgent <: AbstractAgent\n  id::Int # The identifier number of the agent\n  pos::Tuple{Int,Int} # The x, y location of the agent on a 2D grid\n  mood::Bool # whether the agent is happy in its node. (true = happy)\n  group::Int # The group of the agent,  determines mood as it interacts with neighbors\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that the position of this Agent type is a Tuple{Int,Int} because we will use a GridSpace.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We added two more fields for this model, namely a mood field which will store true for a happy agent and false for an unhappy one, and an group field which stores 0 or 1 representing two groups.","category":"page"},{"location":"examples/schelling/#Creating-a-space-1","page":"Schelling's segregation model","title":"Creating a space","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"For this example, we will be using a Moore 2D grid, e.g.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"space = GridSpace((10,10), moore = true)","category":"page"},{"location":"examples/schelling/#Creating-an-ABM-1","page":"Schelling's segregation model","title":"Creating an ABM","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"To make our model we follow the instructions of AgentBasedModel. We also want to include a property min_to_be_happy in our model, and so we have:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"properties = Dict(:min_to_be_happy => 3)\nschelling = ABM(SchellingAgent, space;\n                scheduler = fastest, properties = properties)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Here we used the default scheduler (which is also the fastest one) to create the model. We could instead try to activate the agents according to their property :group, so that all agents of group 1 act first. We would then use the scheduler property_activation like so:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"schelling2 = ABM(SchellingAgent, space; properties = properties,\n                 scheduler = property_activation(:group))","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that partial_activation accepts an argument and returns a function, which is why we didn't just give partial_activation to scheduler.","category":"page"},{"location":"examples/schelling/#Creating-the-ABM-through-a-function-1","page":"Schelling's segregation model","title":"Creating the ABM through a function","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Here we put the model instantiation in a function so that it will be easy to recreate the model and change its parameters.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"In addition, inside this function, we populate the model with some agents. We also change the scheduler to random_activation. Because the function is defined based on keywords, it will be of further use in paramscan below.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"function initialize(;numagents=320, griddims=(20, 20), min_to_be_happy=3)\n    space = GridSpace(griddims, moore = true)\n    properties = Dict(:min_to_be_happy => 3)\n    model = ABM(SchellingAgent, space; properties=properties, scheduler = random_activation)\n    # populate the model with agents, adding equal amount of the two types of agents\n    # at random positions in the model\n    for n in 1:numagents\n        agent = SchellingAgent(n, (1,1), false, n < numagents/2 ? 1 : 2)\n        add_agent_single!(agent, model)\n    end\n    return model\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that the position that an agent is initialized does not matter in this example. This is because it is set properly when adding an agent to the model.","category":"page"},{"location":"examples/schelling/#Defining-a-step-function-1","page":"Schelling's segregation model","title":"Defining a step function","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Finally, we define a step function to determine what happens to an agent when activated.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"function agent_step!(agent, model)\n    agent.mood == true && return # do nothing if already happy\n    minhappy = model.properties[:min_to_be_happy]\n    neighbor_cells = node_neighbors(agent, model)\n    count_neighbors_same_group = 0\n    # For each neighbor, get group and compare to current agent's group\n    # and increment count_neighbors_same_group as appropriately.\n    for neighbor_cell in neighbor_cells\n        node_contents = get_node_contents(neighbor_cell, model)\n        # Skip iteration if the node is empty.\n        length(node_contents) == 0 && continue\n        # Otherwise, get the first agent in the node...\n        agent_id = node_contents[1]\n        # ...and increment count_neighbors_same_group if the neighbor's group is\n        # the same.\n        neighbor_agent_group = model.agents[agent_id].group\n        if neighbor_agent_group == agent.group\n            count_neighbors_same_group += 1\n        end\n    end\n    # After counting the neighbors, decide whether or not to move the agent.\n    # If count_neighbors_same_group is at least the min_to_be_happy, set the\n    # mood to true. Otherwise, move the agent to a random node.\n    if count_neighbors_same_group ≥ minhappy\n        agent.mood = true\n    else\n        move_agent_single!(agent, model)\n    end\n    return\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"For the purpose of this implementation of Schelling's segregation model, we only need an agent step function.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"For defining agent_step! we used some of the built-in functions of Agents.jl, such as node_neighbors that returns the neighboring nodes of the node on which the agent resides, get_node_contents that returns the IDs of the agents on a given node, and move_agent_single! which moves agents to random empty nodes on the grid. A full list of built-in functions and their explanations are available in the API page.","category":"page"},{"location":"examples/schelling/#Running-the-model-1","page":"Schelling's segregation model","title":"Running the model","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Let's initialize the model with 370 agents on a 20 by 20 grid.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize()","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can run the model for one step","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"step!(model, agent_step!)     # run the model one step","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Or for three steps","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"step!(model, agent_step!, 3)  # run the model 3 steps.","category":"page"},{"location":"examples/schelling/#Running-the-model-and-collecting-data-1","page":"Schelling's segregation model","title":"Running the model and collecting data","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can use the same step! function with more arguments to run multiple steps and collect values of our desired fields from every agent and put these data in a DataFrame object.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize()","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We define an array of Symbols for the agent fields that we want to collect as data","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"properties = [:pos, :mood, :group]","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"And specify at which steps data should be collected.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"n = 5  # number of time steps to run the simulation\nwhen = 1:n  # At which steps to collect data","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Use the step! function to run the model and collect data into a DataFrame.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"data = step!(model, agent_step!, n, properties, when=when)\ndata[1:10, :] # print only a few rows","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"With the above properties vector, we collected all agents data. We can instead only collected aggregated data. For example, let's only get the number of happy individuals:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize(numagents=370, griddims=(20,20), min_to_be_happy=3);\nproperties = Dict(:mood => [sum])\nn = 5; when = 1:n\ndata = step!(model, agent_step!, 5, properties, when=when)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"The other Examples pages are more realistic examples with a bit more meaningful data processing steps.","category":"page"},{"location":"examples/schelling/#Visualizing-the-data-1","page":"Schelling's segregation model","title":"Visualizing the data","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can use the plot2D function to plot the distribution of agents on a 2D grid at every generation, via the AgentsPLots package","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using AgentsPlots\nproperties = [:pos, :mood, :group]\ndata = step!(model, agent_step!, 10, properties)\np = plot2D(data, :group, t=1, nodesize=10)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that to see this plot we need the \"raw\" data, not the aggregated data","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"p = plot2D(data, :group, t=2, nodesize=10)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"The first argument of the plot2D is the output data. The second argument is the column name in data that has the categories of each agent, which is :group in this case. nodesize determines the size of cells in the plot.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Custom plots can be easily made with DataVoyager because the outputs of simulations are always as a DataFrame object.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using DataVoyager\nv = Voyager(data)","category":"page"},{"location":"examples/schelling/#Replicates-and-parallel-computing-1","page":"Schelling's segregation model","title":"Replicates and parallel computing","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can run replicates of a simulation and collect all of them in a single DataFrame. To that end, we only need to specify replicates the step! function:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize(numagents=370, griddims=(20,20), min_to_be_happy=3);\ndata = step!(model, agent_step!, 5, properties, when=when, replicates=3)\ndata[end-10:end, :]","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"It is possible to run the replicates in parallel. For that, we should start julia with julia -p n where is the number of processing cores. Alternatively, we can define the number of cores from within a Julia session:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using Distributed\naddprocs(4)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"For distributed computing to work, all definitions must be preceded with @everywhere, e.g.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"@everywhere using Agents\n@everywhere mutable struct SchellingAgent ...","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Then we can tell the step! function to run replicates in parallel:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"data = step!(model, agent_step!, 2, properties,\n             when=when, replicates=5, parallel=true)","category":"page"},{"location":"examples/schelling/#Scanning-parameter-ranges-1","page":"Schelling's segregation model","title":"Scanning parameter ranges","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We often are interested in the effect of different parameters on the behavior of an agent-based model. Agents.jl provides the function paramscan to automatically explore the effect of different parameter values.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We have already defined our model initialization function as initialize. We now also define a processing function, that returns the percentage of happy agents:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"happyperc(moods) = count(x -> x == true, moods)/length(moods)\n\nproperties= Dict(:mood=>[happyperc])\nparameters = Dict(:min_to_be_happy=>collect(2:5), :numagents=>[200,300], :griddims=>(20,20))\n\ndata = paramscan(parameters, initialize;\n       properties=properties, n = 3, agent_step! = agent_step!)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"paramscan also allows running replicates per parameter setting:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"data = paramscan(parameters, initialize; properties=properties, n = 3,\n                 agent_step! = agent_step!, replicates=3)\n\ndata[end-10:end, :]","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can combine all replicates with an aggregating function, such as mean, using the aggregate function from the DataFrames package:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using DataFrames: Not, select!\nusing Statistics: mean\ndata_mean = Agents.aggregate(data, [:step, :min_to_be_happy, :numagents],  mean);\nselect!(data_mean, Not(:replicate_mean))","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Note that the second argument takes the column names on which to split the data, i.e., it denotes which columns should not be aggregated. It should include the :step column and any parameter that changes among simulations. But it should not include the :replicate column. So in principle wha we are doing here is simply averaging our result across the replicates.","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/HK.jl\"","category":"page"},{"location":"examples/HK/#HK-(Hegselmann-and-Krause)-opinion-dynamics-model-1","page":"Hegselmann-Krause opinion dynamics","title":"HK (Hegselmann and Krause) opinion dynamics model","text":"","category":"section"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"This is an implementation of a simple version of the Hegselmann and Krause (2002) model, which also features synchronous updating of Agent properties.","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"It is a model of opinion formation with the question: which parameters' values lead to consensus, polarization or fragmentation? It models interacting groups of agents (as opposed to interacting pairs, typical in the literature) in which it is assumed that if an agent disagrees too much with the opinion of a source of influence, the source can no longer influence the agent’s opinion. There is then a \"bound of confidence\". The model shows that the systemic configuration is heavily dependent on this parameter's value.","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"We implement it as an example of how to implement a Synchronous update schedule . In a Synchronous update schedule changes made to an agent are not seen by other agents until the next clock tick — that is, all agents update simultaneously (Wilensky 2015, p.286).","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"The model has the following components:","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"A set of n Agents with opinions xᵢ in the range [0,1] as attribute;\nA bound ϵ in also in the range [0,1] (actually, the range of interesting results is approximately (0, 0.3]);\nThe update rule: at each step every agent adopts the mean of the opinions which are within the confidence bound ( |xᵢ - xⱼ| ≤ ϵ).","category":"page"},{"location":"examples/HK/#Core-structures-1","page":"Hegselmann-Krause opinion dynamics","title":"Core structures","text":"","category":"section"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"We start by defining the Agent type and initializing the model. The Agent type has two fields so that we can implement the synchronous update.","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"using Agents\nusing Statistics: mean\n\nmutable struct HKAgent <: AbstractAgent\n    id::Int\n    old_opinion::Float64\n    new_opinion::Float64\nend\n\nfunction hk_model(;numagents = 100, ϵ = 0.4)\n    model = ABM(HKAgent, scheduler = fastest,\n                properties = Dict(:ϵ => ϵ))\n    for i in 1:numagents\n        o = rand()\n        add_agent!(model, o, o)\n    end\n    return model\nend","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"And some helper functions for the update rule. As there is a filter in the rule we implement it outside the agent_step! method. Notice that the filter is applied to the :old_opinion field.","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"get_old_opinion(agent)::Float64 = agent.old_opinion\n\nfunction boundfilter(agent,model)\n    filter(j->abs(get_old_opinion(agent) - j) < model.properties[:ϵ],\n     get_old_opinion.(values(model.agents)))\nend","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"Now we implement the agent_step! and model_step! methods.","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"function agent_step!(agent, model)\n    agent.new_opinion = mean(boundfilter(agent,model))\nend\n\nfunction updateold(a)\n    a.old_opinion = a.new_opinion\n    return a\nend\n\nfunction model_step!(model)\n    for i in keys(model.agents)\n        agent = id2agent(i, model)\n        updateold(agent)\n    end\nend","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"From this implementation we see that to implement synchronous scheduling we define an Agent type with an old and new fields for attributes that are changed through synchronous updating. In agent_step! we use the old field and after updating all the agents new field we use the model_step! to update the model  for the next iteration.","category":"page"},{"location":"examples/HK/#Running-the-model-1","page":"Hegselmann-Krause opinion dynamics","title":"Running the model","text":"","category":"section"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"Now we can define a method for our simulation run. The parameter of interest is the :new_opinion field so we assign it to variable agent_properties and pass it to the step! method to be collected in a DataFrame.","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"function model_run(; numagents = 100, iterations = 50, ϵ= 0.05)\n    model = hk_model(numagents = numagents, ϵ = ϵ)\n    when = 0:5:iterations\n    agent_properties = [:new_opinion]\n    data = step!(\n            model,\n            agent_step!,\n            model_step!,\n            iterations,\n            agent_properties,\n            when = when\n            )\n    return(data)\nend\n\ndata = model_run(numagents = 10, iterations = 20)\ndata[end-19:end, :]","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"Finally we run three scenarios, collect the data and plot it.","category":"page"},{"location":"examples/HK/#","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"using Plots\n\nplotsim(data, ϵ) = plot(\n                        data[!, :step],\n                        data[!, :new_opinion],\n                        leg= false,\n                        group = data[!, :id],\n                        title = \"epsilon = $(ϵ)\"\n                        )\n\nplt001,plt015,plt03 = map(\n                          e -> (model_run(ϵ= e), e) |>\n                          t -> plotsim(t[1], t[2]),\n                          [0.05, 0.15, 0.3]\n                          )\n\nplot(plt001, plt015, plt03, layout = (3,1))","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/wright-fisher.jl\"","category":"page"},{"location":"examples/wright-fisher/#Wright-Fisher-model-of-evolution-1","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"","category":"section"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"This is one of the simplest models of population genetics that demonstrates the use of sample!. We implement a simple case of the model where we study haploids (cells with a single set of chromosomes) while for simplicity focusing only on one locus (a specific gene). In this example we will be dealing with a population of constant size.","category":"page"},{"location":"examples/wright-fisher/#A-neutral-model-1","page":"Wright-Fisher model of evolution","title":"A neutral model","text":"","category":"section"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"Imagine a population of n haploid individuals.\nAt each generation, n offsprings replace the parents.\nEach offspring chooses a parent at random and inherits its genetic material.","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"using Agents\nn = 100","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"Let's define an agent. The genetic value of an agent is a number (trait field).","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"mutable struct Haploid <: AbstractAgent\n    id::Int\n    trait::Float64\nend","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"And make a model without any spatial structure:","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"m = ABM(Haploid)","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"Create n random individuals:","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"for i in 1:n\n    add_agent!(m, rand())\nend","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"To create a new generation, we can use the sample! function. It chooses random individuals with replacement from the current individuals and updates the model. For example:","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"sample!(m, nagents(m))","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"The model can be run for many generations and we can collect the average trait value of the population. To do this we will use a model-step function (see step!) that utilizes sample!:","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"modelstep_neutral!(m) = sample!(m, nagents(m))","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"We can now run the model and collect data. We use dummystep for the agent-step function (as the agents perform no actions).","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"using Statistics: mean\n\ndata = step!(m, dummystep, modelstep_neutral!, 20, Dict(:trait => [mean]))","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"As expected, the average value of the \"trait\" remains around 0.5.","category":"page"},{"location":"examples/wright-fisher/#A-model-with-selection-1","page":"Wright-Fisher model of evolution","title":"A model with selection","text":"","category":"section"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"We can sample individuals according to their trait values, supposing that their fitness is correlated with their trait values.","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"m = ABM(Haploid)\nfor i in 1:100\n    add_agent!(m, rand())\nend\n\nmodelstep_selection!(m::ABM) = sample!(m, nagents(m), :trait)\n\ndata = step!(m, dummystep, modelstep_selection!, 20, Dict(:trait => [mean]))","category":"page"},{"location":"examples/wright-fisher/#","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"Here we see that as time progresses the trait comes closer and closer to 1, which is expected as agents with higher traits have higher probability of being sampled for the next \"generation\".","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The core API is defined by AgentBasedModel, Space, AbstractAgent and step!, which are described in the Tutorial page. The functionality described here builds on top of the core API.","category":"page"},{"location":"api/#Agent-information-and-retrieval-1","page":"API","title":"Agent information and retrieval","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"space_neighbors\nid2agent\nrandom_agent\nnagents\nallagents","category":"page"},{"location":"api/#Agents.space_neighbors","page":"API","title":"Agents.space_neighbors","text":"space_neighbors(position, model::ABM [, r]) → ids\n\nReturn the ids of the agents neighboring the given position (which must match type with the spatial structure of the model). If r is given, it is the radius to search for agents.\n\nFor DiscreteSpaces r must be integer and defines higher degree neighbors. For example, for r=2 include first and second degree neighbors, that is, neighbors and neighbors of neighbors.\n\nFor ContinuousSpace, r is real number and finds all neighbors within distance r (based on the space's metric).\n\nSee also node_neighbors.\n\nr defaults to 1 for DiscreteSpace but is mandatory for ContinuousSpace.\n\nspace_neighbors(agent::AbstractAgent, model::ABM [, r]) → ids\n\nCall space_neighbors(agent.pos, model, r) but exclude the given agent from the neighbors.\n\n\n\n\n\nspace_neighbors(pos::Tuple, model::ABM, r::Real)\n\nReturn IDs of all agents within radius r from a particular position pos for any space.\n\n\n\n\n\nspace_neighbors(agent::AbstractAgent, model::ABM, r::Real)\n\nReturn neighbours of a particular agent, within radius r for any space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.id2agent","page":"API","title":"Agents.id2agent","text":"id2agent(id::Integer, model)\n\nReturn an agent given its ID.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_agent","page":"API","title":"Agents.random_agent","text":"random_agent(model)\n\nReturn a random agent from the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nagents","page":"API","title":"Agents.nagents","text":"nagents(model::ABM)\n\nReturn the number of agents in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.allagents","page":"API","title":"Agents.allagents","text":"allagents(model)\n\nReturn an iterator over all agents of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Model-Agent-interaction-1","page":"API","title":"Model-Agent interaction","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The following API is mostly universal across all types of Space. Only some specific methods are exclusive to a specific type of space, but we think this is clear from the documentation strings (if not, please open an issue!).","category":"page"},{"location":"api/#","page":"API","title":"API","text":"add_agent!\nadd_agent_pos!\nadd_agent_single!\nmove_agent!\nmove_agent_single!\nkill_agent!\ngenocide!","category":"page"},{"location":"api/#Agents.add_agent!","page":"API","title":"Agents.add_agent!","text":"add_agent!(agent::AbstractAgent [, position], model::ABM) → agent\n\nAdd the agent to the position in the space and to the list of agents. If position is not given, the agent is added to a random position. The agent's position is always updated to match position, and therefore for add_agent! the position of the agent is meaningless. Use add_agent_pos! to use the agent's position.\n\n\n\n\n\nadd_agent!([position, ] model::ABM, properties...)\n\nAdd a new agent at the given position, by constructing the agent type of the model and propagating all extra properties to the agent constructor.\n\nNotice that this function takes care of setting the agent's id and position and thus properties... is propagated to other fields the agent has.\n\nadd_agent!(model::ABM, properties...)\n\nSimilar with add_agent!(position, model, properties...), but adds the created agent to a random position. This function also works for models without a spatial structure.\n\nExample\n\nusing Agents\nmutable struct Agent <: AbstractAgent\n    id::Int\n    w::Float64\nend\nm = ABM(Agent) # model without spatial structure\nadd_agent!(m, 1, rand()) # incorrect: id is set internally\nadd_agent!(m, rand()) # correct: weight becomes rand()\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_agent_pos!","page":"API","title":"Agents.add_agent_pos!","text":"add_agent_pos!(agent::AbstractAgent, model::ABM) → agent\n\nAdd the agent to the model at the agent's own position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_agent_single!","page":"API","title":"Agents.add_agent_single!","text":"add_agent_single!(agent::A, model::ABM{A, <: DiscreteSpace}, verbose = true) → agent\n\nAdd agent to a random node in the space while respecting a maximum one agent per node. This function throws a warning if no empty nodes remain.\n\n\n\n\n\nadd_agent_single!(model::ABM, properties...)\n\nSame as add_agent!(model, properties...) but ensures that it adds an agent into a node with no other agents (does nothing if no such node exists).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.move_agent!","page":"API","title":"Agents.move_agent!","text":"move_agent!(agent::A [, pos], model::ABM{A, <: DiscreteSpace}) → agent\n\nAdd agentID to the new position pos (or a random one if pos is not given) in the model and remove it from the old position (also update the agent to have the new position). pos must be the appropriate position type depending on the space type.\n\n\n\n\n\nmove_agent!(agent::A, model::ABM{A, ContinuousSpace}, dt = 1.0)\n\nPropagate the agent forwards one step according to its velocity, after updating the agent's velocity (see ContinuousSpace).\n\nFor this continuous space version of move_agent!, the \"evolution algorithm\" is a trivial Euler scheme with dt the step size, i.e. the agent position is updated as agent.pos += agent.vel * dt.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.move_agent_single!","page":"API","title":"Agents.move_agent_single!","text":"move_agent_single!(agent::AbstractAgent, model::ABM) → agent\n\nMove agent to a random node while respecting a maximum of one agent per node. If there are no empty nodes, the agent wont move. Only valid for non-continuous spaces.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.kill_agent!","page":"API","title":"Agents.kill_agent!","text":"kill_agent!(agent::AbstractAgent, model::ABM)\n\nRemove an agent from model, and from the space if the model has a space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.genocide!","page":"API","title":"Agents.genocide!","text":"genocide!(model::ABM)\n\nKill all the agents of the model.\n\n\n\n\n\ngenocide!(model::ABM, n::Int)\n\nKill the agents of the model whose IDs are larger than n.\n\n\n\n\n\ngenocide!(model::ABM, f::Function)\n\nKill all agents where the function f(agent) returns true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Discrete-space-exclusives-1","page":"API","title":"Discrete space exclusives","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"node_neighbors\nnv(::ABM)\nne(::ABM)\nhas_empty_nodes\nfind_empty_nodes\npick_empty\nget_node_contents\nget_node_agents\nisempty(::Integer, ::ABM)\nNodeIterator\nnodes\ncoord2vertex\nvertex2coord","category":"page"},{"location":"api/#Agents.node_neighbors","page":"API","title":"Agents.node_neighbors","text":"node_neighbors(node, model::ABM{A, <:DiscreteSpace} [, r]) → nodes\n\nReturn all nodes that are neighbors to the given node, which can be an Int for GraphSpace, or a NTuple{Int} for GridSpace.\n\nOptional argument r is the radius, similar with space_neighbors.\n\nnode_neighbors(agent, model::ABM{A, <:DiscreteSpace} [, r]) → nodes\n\nSame as above, but uses agent.pos as node.\n\n\n\n\n\n","category":"function"},{"location":"api/#LightGraphs.nv-Tuple{AgentBasedModel}","page":"API","title":"LightGraphs.nv","text":"nv(model::ABM)\n\nReturn the number of nodes (vertices) in the model space.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightGraphs.ne-Tuple{AgentBasedModel}","page":"API","title":"LightGraphs.ne","text":"ne(model::ABM)\n\nReturn the number of edges in the model space.\n\n\n\n\n\n","category":"method"},{"location":"api/#Agents.has_empty_nodes","page":"API","title":"Agents.has_empty_nodes","text":"has_empty_nodes(model)\n\nReturn true if there are empty nodes in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.find_empty_nodes","page":"API","title":"Agents.find_empty_nodes","text":"find_empty_nodes(model::ABM)\n\nReturns the indices of empty nodes on the model space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.pick_empty","page":"API","title":"Agents.pick_empty","text":"pick_empty(model)\n\nReturn a random empty node or 0 if there are no empty nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.get_node_contents","page":"API","title":"Agents.get_node_contents","text":"get_node_contents(n::Integer, model)\n\nReturn the ids of agents in the node n of the model.\n\n\n\n\n\nget_node_contents(agent::AbstractAgent, model)\n\nReturn all agents' ids in the same node as the agent (including the agent's own id).\n\n\n\n\n\nget_node_contents(coords::Tuple, model)\n\nReturn the ids of agents in the node at coords.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.get_node_agents","page":"API","title":"Agents.get_node_agents","text":"get_node_agents(x, model)\n\nSame as get_node_contents(x, model) but directly returns the list of agents instead of just the list of IDs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.isempty-Tuple{Integer,AgentBasedModel}","page":"API","title":"Base.isempty","text":"isempty(node::Int, model::ABM)\n\nReturn true if there are no agents in node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Agents.NodeIterator","page":"API","title":"Agents.NodeIterator","text":"NodeIterator(model) → iterator\n\nCreate an iterator that returns node coordinates, if the space is a grid, or otherwise node number, and the agent IDs in each node.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.nodes","page":"API","title":"Agents.nodes","text":"nodes(model; by = :id) -> ns\n\nReturn a vector of the node ids of the model that you can iterate over. The ns are sorted depending on by:\n\n:id - just sorted by their number\n:random - randomly sorted\n:population - nodes are sorted depending on how many agents they accommodate. The more populated nodes are first.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.coord2vertex","page":"API","title":"Agents.coord2vertex","text":"coord2vertex(coord::NTuple{Int}, model_or_space) → n\ncoord2vertex(coord::AbstractAgent, model_or_space) → n\n\nReturn the node number n of the given coordinates or the agent's position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.vertex2coord","page":"API","title":"Agents.vertex2coord","text":"vertex2coord(vertex::Integer, model_or_space) → coords\n\nReturns the coordinates of a node given its number on the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#Continuous-space-exclusives-1","page":"API","title":"Continuous space exclusives","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"interacting_pairs\nnearest_neighbor\nelastic_collision!\nindex!","category":"page"},{"location":"api/#Agents.interacting_pairs","page":"API","title":"Agents.interacting_pairs","text":"interacting_pairs(model, r)\n\nReturn an iterator that yields pairs of agents (a1, a2) that are closest neighbors to each other, within some interaction radius r.\n\nThis function is usefully combined with model_step!, when one wants to perform some pairwise interaction across all pairs of closest agents once (and does not want to trigger the event twice, both with a1 and with a2, which is unavoidable when using agent_step!).\n\nInternally uses nearest_neighbor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nearest_neighbor","page":"API","title":"Agents.nearest_neighbor","text":"nearest_neighbor(agent, model, r) → nearest\n\nReturn the agent that has the closest distance to given agent, according to the space's metric. Valid only in continuous space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.elastic_collision!","page":"API","title":"Agents.elastic_collision!","text":"elastic_collision!(a, b, f = nothing)\n\nResolve a (hypothetical) elastic collision between the two agents a, b. They are assumed to be disks of equal size touching tangentially. Their velocities (field vel) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.\n\nIf f is a Symbol, then the agent property f, e.g. :mass, is taken as a mass to weight the two agents for the collision. By default no weighting happens.\n\nOne of the two agents can have infinite \"mass\", and then acts as an immovable object that specularly reflects the other agent. In this case of course momentum is not conserved, but kinetic energy is still conserved.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.index!","page":"API","title":"Agents.index!","text":"index!(model)\n\nIndex the database underlying the ContinuousSpace of the model.\n\nThis can drastically improve performance for retrieving data, but adding new data can become slower because after each addition, index needs to be called again.\n\nLack of index won't be noticed for small databases. Only use it when you have many agents and not many additions of agents.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulations-1","page":"API","title":"Simulations","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The central simulation function is step!, which is mentioned in our Tutorial. But there are other functions that are related to simulations listed here.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"paramscan\nsample!","category":"page"},{"location":"api/#Agents.paramscan","page":"API","title":"Agents.paramscan","text":"paramscan(parameters, initialize; kwargs...)\n\nRun the model with all the parameter value combinations given in parameters, while initializing the model with initialize. This function uses DrWatson's dict_list internally. This means that every entry of parameters that is a Vector, contains many parameters and thus is scanned. All other entries of parameters that are not Vectors are not expanded in the scan.\n\ninitialize is a function that creates an ABM. It should accept keyword arguments.\n\nKeywords\n\nAll the following keywords are propagated into step!: agent_step!, properties, n, when = 1:n, model_step! = dummystep, step0::Bool = true, parallel::Bool = false, replicates::Int = 0.\n\nThe following keywords modify the paramscan function:\n\ninclude_constants::Bool=false determines whether constant parameters should be included in the output DataFrame.\n\nprogress::Bool = true whether to show the progress of simulations.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.sample!","page":"API","title":"Agents.sample!","text":"sample!(model::ABM, n [, weight]; kwargs...)\n\nReplace the agents of the model with a random sample of the current agents with size n.\n\nOptionally, choose an agent property weight (Symbol) to weight the sampling. This means that the higher the weight of the agent, the higher the probability that this agent will be chosen in the new sampling.\n\nKeywords\n\nreplace = true : whether sampling is performed with replacement, i.e. all agents can be chosen more than once.\nrng = GLOBAL_RNG : a random number generator to perform the sampling with.\n\nSee the Wright-Fisher example in the documentation for an application of sample!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Schedulers-1","page":"API","title":"Schedulers","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The schedulers of Agents.jl have a very simple interface. All schedulers are functions, that take as an input the ABM and return an iterator over agent IDs. Notice that this iterator can be a \"true\" iterator or can be just a standard vector of IDs. You can define your own scheduler according to this API and use it when making an AgentBasedModel.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"fastest\nby_id\nrandom_activation\npartial_activation\nproperty_activation","category":"page"},{"location":"api/#Agents.fastest","page":"API","title":"Agents.fastest","text":"fastest\n\nActivate all agents once per step in the order dictated by the agent's container, which is arbitrary (the keys sequence of a dictionary). This is the fastest way to activate all agents once per step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.by_id","page":"API","title":"Agents.by_id","text":"by_id\n\nActivate agents at each step according to their id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_activation","page":"API","title":"Agents.random_activation","text":"random_activation\n\nActivate agents once per step in a random order. Different random ordering is used at each different step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.partial_activation","page":"API","title":"Agents.partial_activation","text":"partial_activation(p)\n\nAt each step, activate only p percentage of randomly chosen agents.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.property_activation","page":"API","title":"Agents.property_activation","text":"property_activation(property)\n\nAt each step, activate the agents in an order dictated by their property, with agents with greater property acting first. property is a Symbol, which just dictates which field the agents to compare.\n\n\n\n\n\n","category":"function"},{"location":"api/#Parallelization-1","page":"API","title":"Parallelization","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"parallel_replicates","category":"page"},{"location":"api/#Agents.parallel_replicates","page":"API","title":"Agents.parallel_replicates","text":"parallel_replicates(agent_step!, model::ABM, n::Integer, agent_properties::Array{Symbol}, when::AbstractArray{Integer}, replicates::Integer)\n\nRuns replicates number of simulations in parallel and returns a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/#Plotting-1","page":"API","title":"Plotting","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Plotting functionality comes from AgentsPlots, which uses Plots.jl. You need to install both AgentsPlots, as well as a plotting backend (we use GR) to use the following functions.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"plotabm\nplot2D\nplot_CA1D\nplot_CA2D\nplot_CA2Dgif","category":"page"},{"location":"api/#AgentsPlots.plotabm","page":"API","title":"AgentsPlots.plotabm","text":"plotabm(model::ABM{A, <: GraphSpace}, [, c , s]; kwargs...)\n\nPlot the model as a graph by providing two optional functions c, s. Both of these functions gain as an input the list of agents a at a node of the model's graph. c returns a color (anything acceptable by Plots.jl) of the node while s returns the (relative) size of the node.\n\nc defaults to a purple color for all nodes, while s defaults to length. Internally the graphplot recipe is used, and thus all keyword arguments are propagated into this recipe.\n\nIf you use plotabm in an animation loop, notice that not all method types of graphplot are deterministic and thus you should probably set Random.seed! before each call to plotabm (and call Random.seed!(rand(1:10000)) afterwards to ensure random behavior for your abm).\n\n\n\n\n\nplotabm(model::ABM{A, <: ContinuousSpace}; ac, as, am, kwargs...)\n\nPlot all agents of the model on continuous space by (optionally) configuring how to plot the agents with keywords ac, as, am.\n\nac = agent color, as = agent size, am = agent marker shape.\n\nThese arguments can be constants (numbers, strings, etc.), and then all agents get the same property. Or, they can be functions, that take as input the list of agents, and output a vector of colors, sizes, or shapes (anything acceptable by scatter).\n\nDefaults: ac = \"#765db4\", as = 8, am = :o. All other keywords are propatted into Plots.scatter.\n\n\n\n\n\n","category":"function"},{"location":"api/#AgentsPlots.plot2D","page":"API","title":"AgentsPlots.plot2D","text":"plot2D(node_coords::AbstractArray, colors::AbstractArray; kwargs...)\n\nCreates a scatter plot for nodes and their colors\n\nnode_coords: node positions as coordinates\ncolors: color of each node\n\nKeywords\n\nnodesize=1.0\nmarkeralpha = nothing\n\n\n\n\n\nplot2D(data::AbstractDataFrame, status_column::Symbol; kwargs)\n\nPlots the distribution of agents on a 2D grid. Agent positions should be saved as tuples.\n\ndata: A dataframe output of your simulation.\nstatus_column: the name of a column that determines category of each agent,  so that it is colored differently.\n\nKeywords\n\ncc::Dict=Dict() Optionally provide a color name for each unique value in the status_column\nnodesize=1.0 size of each node\nt=0 the time step of the simulation to plot.\n\n\n\n\n\n","category":"function"},{"location":"api/#AgentsPlots.plot_CA1D","page":"API","title":"AgentsPlots.plot_CA1D","text":"plot_CA1D(data; Keywords)\n\nVisualizes data of a 1D cellular automaton.\n\ndata: output of CA1D.ca_run.\n\nKeywords\n\nnodesize=2.0: Size of each cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#AgentsPlots.plot_CA2D","page":"API","title":"AgentsPlots.plot_CA2D","text":"plot_CA2D(data; kwargs...)\n\nVisualizes data of a 2D cellular automaton.\n\ndata: output of CA2D.ca_run.\n\nKeywords\n\nt=nothing : The time step to be plotted. If nothing, all the rows in data are used.\nnodesize=2.0\n\n\n\n\n\n","category":"function"},{"location":"api/#AgentsPlots.plot_CA2Dgif","page":"API","title":"AgentsPlots.plot_CA2Dgif","text":"plot_CA2Dgif(data; kwargs...)\n\nCreate a 2D scatter plot from all data and adds a frame to the anim animation object. If anim is not provided, it creates a new one. Returns an animation object. It can be saved as an animated gif using AgentsPlots.gif(anim, \"filename.gif\").\n\ndata: output of of time-step of CA2D.ca_run.\n\nKeywords\n\nanim::Animation=Animation() : animation object. If provided, a new frame is added to it.\nnodesize=2.0\n\n\n\n\n\n","category":"function"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/forest_fire.jl\"","category":"page"},{"location":"examples/forest_fire/#Forest-fire-model-1","page":"Forest fire","title":"Forest fire model","text":"","category":"section"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"The forest fire model is defined as a cellular automaton on a grid. A cell can be empty, occupied by a tree, or burning. The model of Drossel and Schwabl (1992) is defined by four rules which are executed simultaneously:","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"A burning cell turns into an empty cell\nA tree will burn if at least one neighbor is burning\nA tree ignites with probability f even if no neighbor is burning\nAn empty space fills with a tree with probability p","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"The forest has an innate density d, which is the proportion of trees initialized as green. This model is an example that does not have an agent_step! function. It only uses a model_step!","category":"page"},{"location":"examples/forest_fire/#Defining-the-core-structures-1","page":"Forest fire","title":"Defining the core structures","text":"","category":"section"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"We start by defining the agent type","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"using Agents, Random\n\nmutable struct Tree <: AbstractAgent\n    id::Int\n    pos::Tuple{Int, Int}\n    status::Bool  # true is green and false is burning\nend","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"The agent type Tree has three fields: id and pos, which have to be there for any agent, and a status field that we introduce for this specific model. The status field will hold true for a green tree and false for a burning one. All other model parameters go into the AgentBasedModel","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"We then make a setup function that initializes the model","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"function model_initiation(; f, d, p, griddims, seed = 111)\n    Random.seed!(seed)\n    space = GridSpace(griddims, moore = true)\n    properties = Dict(:f => f, :d => d, :p => p)\n    forest = AgentBasedModel(Tree, space; properties=properties)\n\n    # create and add trees to each node with probability d,\n    # which determines the density of the forest\n    for node in nodes(forest)\n        if rand() ≤ forest.properties[:d]\n            add_agent!(node, forest, true)\n        end\n    end\n    return forest\nend\n\nforest = model_initiation(f=0.05, d=0.8, p=0.05, griddims=(20, 20), seed=2)","category":"page"},{"location":"examples/forest_fire/#Defining-the-step!-1","page":"Forest fire","title":"Defining the step!","text":"","category":"section"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"Because of the way the forest fire model is defined, we only need a stepping function for the model","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"function forest_step!(forest)\n  for node in nodes(forest, by = :random)\n    nc = get_node_contents(node, forest)\n    # the cell is empty, maybe a tree grows here\n    if length(nc) == 0\n        rand() ≤ forest.properties[:p] && add_agent!(node, forest, true)\n    else\n      tree = id2agent(nc[1], forest) # by definition only 1 agent per node\n      if tree.status == false  # if it is has been burning, remove it.\n        kill_agent!(tree, forest)\n      else\n        if rand() ≤ forest.properties[:f]  # the tree ignites spntaneously\n          tree.status = false\n        else  # if any neighbor is on fire, set this tree on fire too\n          for cell in node_neighbors(node, forest)\n            neighbors = get_node_contents(cell, forest)\n            length(neighbors) == 0 && continue\n            if any(n -> !forest.agents[n].status, neighbors)\n              tree.status = false\n              break\n            end\n          end\n        end\n      end\n    end\n  end\nend","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"as we discussed, there is no agent_step! function here, so we will just use dummystep.","category":"page"},{"location":"examples/forest_fire/#Running-the-model-1","page":"Forest fire","title":"Running the model","text":"","category":"section"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"step!(forest, dummystep, forest_step!)\nforest","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"step!(forest, dummystep, forest_step!, 10)\nforest","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"Now we can do some data collection as well using an aggregate function percentage:","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"forest = model_initiation(f=0.05, d=0.8, p=0.01, griddims=(20, 20), seed=2)\npercentage(x) = count(x)/nv(forest)\nagent_properties = Dict(:status => [percentage])\n\ndata = step!(forest, dummystep, forest_step!, 10, agent_properties)","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"Or we can just collect raw data without aggregation:","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"forest = model_initiation(f=0.05, d=0.8, p=0.01, griddims=(20, 20), seed=2)\nagent_properties = [:status, :pos]\n\ndata = step!(forest, dummystep, forest_step!, 10, agent_properties);\nnothing #hide","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"And plot the green and burning trees:","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"using AgentsPlots","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"At time 1","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"p = plot2D(data, :status, t=1, cc=Dict(true=>\"green\", false=>\"red\"), nodesize=8)","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"At time 2","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"p = plot2D(data, :status, t=2, cc=Dict(true=>\"green\", false=>\"red\"), nodesize=8)","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"Or we can run parallel/batch simulations","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"agent_properties = [:status, :pos]\ndata = step!(forest, dummystep, forest_step!, 10, agent_properties, replicates=10)","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"Remember that it is possible to explore a DataFrame visually and interactively through DataVoyager, by doing","category":"page"},{"location":"examples/forest_fire/#","page":"Forest fire","title":"Forest fire","text":"using DataVoyager\nVoyager(data)","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/social_distancing.jl\"","category":"page"},{"location":"examples/social_distancing/#Continuous-space-social-distancing-for-COVID-19-1","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"","category":"section"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"This is a model similar to our SIR model for the spread of COVID-19. But instead of having different cities, we let agents move in one continuous space and transfer the disease if they come into contact with one another. This model is partly inspired by this article, and can complement the SIR graph model. The graph model can model virus transfer between cities, while the current model can be used to study what happens within a city.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"This example serves also as an introduction to using continuous space, modelling billiard-like collisions in that space, and animating the agent motion in the space. Notice that a detailed description of the basics of the model regarding disease spreading exists in the SIR example, and is not repeated here.","category":"page"},{"location":"examples/social_distancing/#Moving-agents-in-continuous-space-1","page":"Continuous space social distancing for COVID-19","title":"Moving agents in continuous space","text":"","category":"section"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Let us first create a simple model were balls move around in a continuous space. We need to create agents that comply with ContinuousSpace, i.e. they have a pos and vel fields, both of which are tuples of float numbers.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"using Agents, Random, AgentsPlots, Plots\nmutable struct Agent <: AbstractAgent\n    id::Int\n    pos::NTuple{2, Float64}\n    vel::NTuple{2, Float64}\n    mass::Float64\nend","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"The mass field will come in handy later on, when we implement social isolation (i.e. that some agents don't move and can't be moved).","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Let's also initialize a trivial model with continuous space","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"function ball_model(; speed = 0.002)\n    space2d = ContinuousSpace(2; periodic = true, extend = (1, 1))\n    model = ABM(Agent, space2d, properties = Dict(:dt => 1.0));\n\n    # And add some agents to the model\n    Random.seed!(42)\n    for ind in 1:500\n        pos = Tuple(rand(2))\n        vel = sincos(2π*rand()) .* speed\n        add_agent!(pos, model, vel, 1.0)\n    end\n    index!(model)\n    return model\nend\n\nmodel = ball_model()","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We took advantage of the functionality of add_agent! that creates the agents automatically. For now all agents have the same absolute speed, and mass. We index! the model, to make finding space neighbors faster.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"The agent step function for now is trivial. It is just move_agent! in continuous space","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"agent_step!(agent, model) =  move_agent!(agent, model, model.properties[:dt])","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"dt is our time resolution, but we will talk about this more later! Cool, let's see now how this model evolves.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"anim = @animate for i ∈ 1:1000\n    p1 = plotabm(model, as = 4)\n    title!(p1, \"step $(i)\")\n    step!(model, agent_step!, 1)\nend\ngif(anim, \"socialdist1.gif\", fps = 45);\nnothing #hide","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"(Image: )","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"As you can see the agents move in a straight line in periodic space. There is no interaction yet. Let's change that.","category":"page"},{"location":"examples/social_distancing/#Billiard-like-interaction-1","page":"Continuous space social distancing for COVID-19","title":"Billiard-like interaction","text":"","category":"section"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We will model the agents as balls that collide with each other. To this end, we will use two functions from the continuous space API:","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"interacting_pairs\nelastic_collision!","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We want all agents to interact in one go, and we want to avoid double interactions (as instructed by interacting_pairs), so we define a model step","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"function model_step!(model)\n    for (a1, a2) in interacting_pairs(model, 0.012)\n    elastic_collision!(a1, a2, :mass)\n    end\nend\n\nmodel2 = ball_model()\n\nanim = @animate for i ∈ 1:100\n    p1 = plotabm(model2, as = 4)\n    title!(p1, \"step $(i)\")\n    step!(model2, agent_step!, model_step!, 1)\nend\ngif(anim, \"socialdist2.gif\", fps = 45);\nnothing #hide","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"(Image: )","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Alright, this works great so far!","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"warning: Agents.jl is not a billiards simulator!\nPlease understand that Agents.jl does not accurately simulate billiard systems. This is the job of Julia packages HardSphereDynamics.jl or DynamicalBilliards.jl. In Agents.jl we only provide an approximating function elastic_collision!. The accuracy of this simulation increases as the time resolution dt decreases, but even in the limit dt → 0 we still don't reach the accuracy of proper billiard packages.Also notice that the plotted size of the circles representing agents is not deduced from the interaction_radius (as it should). We only eye-balled it to look similar enough.","category":"page"},{"location":"examples/social_distancing/#Immovable-agents-1","page":"Continuous space social distancing for COVID-19","title":"Immovable agents","text":"","category":"section"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"For the following social distancing example, it will become crucial that some agents don't move, and can't be moved (i.e. they stay \"isolated\"). This is very easy to do with the elastic_collision! function, we only have to make some agents have infinite mass","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"model3 = ball_model()\n\nfor id in 1:400\n    agent = id2agent(id, model3)\n    agent.mass = Inf\n    agent.vel = (0.0, 0.0)\nend","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"let's animate this again","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"anim = @animate for i ∈ 1:1000\n    p1 = plotabm(model3, as = 4)\n    title!(p1, \"step $(i)\")\n    step!(model3, agent_step!, model_step!, 1)\nend\ngif(anim, \"socialdist3.gif\", fps = 45);\nnothing #hide","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"(Image: )","category":"page"},{"location":"examples/social_distancing/#Adding-Virus-spread-(SIR)-1","page":"Continuous space social distancing for COVID-19","title":"Adding Virus spread (SIR)","text":"","category":"section"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We now add more functionality to these agents, according to the SIR model (see previous example). They can be infected with a disease and transfer the disease to other agents around them.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"mutable struct PoorSoul <: AbstractAgent\n    id::Int\n    pos::NTuple{2, Float64}\n    vel::NTuple{2, Float64}\n    mass::Float64\n    days_infected::Int  # number of days since is infected\n    status::Symbol  # :S, :I or :R\n    β::Float64\nend","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Here β is the transmission probability, which we choose to make a agent parameter instead of model parameter. It can reflect the level of hygiene of the individual. In a realistic scenario, the actual virus transimission would depend on the β value of both agents, but we don't do that here for simplicity.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"And we also significantly modify the model creation, to have SIR-related parameters. Each step in the model corresponds to one hour","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"const steps_per_day = 24\n\nusing DrWatson: @dict\nfunction sir_initiation(;\n        infection_period = 30*steps_per_day, detection_time = 14*steps_per_day,\n        reinfection_probability = 0.05,\n        isolated = 0.0, # in percentage\n        interaction_radius = 0.012, dt = 1.0, speed = 0.002,\n        death_rate = 0.044, # from website of WHO\n        N=1000,\n        initial_infected=5, seed=42,\n        βmin = 0.4, βmax = 0.8\n    )\n\n    properties = @dict(\n        infection_period, reinfection_probability,\n        detection_time, death_rate, interaction_radius, dt,\n    )\n    space = ContinuousSpace(2)\n    model = ABM(PoorSoul, space, properties=properties)\n\n    # Add initial individuals\n    Random.seed!(seed)\n    for ind in 1:N\n        pos = Tuple(rand(2))\n        status = ind ≤ N - initial_infected ? :S : :I\n        isisolated = ind ≤ isolated*N\n        mass = isisolated ? Inf : 1.0\n        vel = isisolated ? (0.0, 0.0) : sincos(2π*rand()) .* speed\n\n        # very high transmission probability\n        # we are modelling close encounters after all\n        β = (βmax-βmin)*rand() + βmin\n        add_agent!(pos, model, vel, mass, 0, status, β)\n    end\n\n    Agents.index!(model)\n    return model\nend","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Notice the constant steps_per_day, which approximates how many model steps correspond to one day (since the parameters we used in the previous graph SIR example were given in days).","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"To visualize this model, we will use black color for the susceptiblue, red for the infected infected and green for the recovered, leveraging plotabm.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"sir_model = sir_initiation()\n\nsir_colors(a) = a.status == :S ? \"#2b2b33\" : a.status == :I ? \"#bf2642\" : \"#338c54\"\n\nplotabm(sir_model; ac = sir_colors, as = 4)","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We have increased the size of the model 10-fold (for more realistic further analysis)","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"To actually spread the virus, we modify the model_step! function, so that individuals have a probability to transmit the disease as they interact.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"function transmit!(a1, a2, rp)\n    # for transmission, only 1 can have the disease (otherwise nothing happens)\n    count(a.status == :I for a in (a1, a2)) ≠ 1 && return\n    infected, healthy = a1.status == :I ? (a1, a2) : (a2, a1)\n\n    rand() > infected.β && return\n\n    if healthy.status == :R\n        rand() > rp && return\n    end\n    healthy.status = :I\nend\n\nfunction sir_model_step!(model)\n    r = model.properties[:interaction_radius]\n    for (a1, a2) in interacting_pairs(model, r)\n        transmit!(a1, a2, model.properties[:reinfection_probability])\n        elastic_collision!(a1, a2, :mass)\n    end\nend","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Notice that it is not necessary that the transmission interaction radius is the same as the billiard-ball dynamics. We only have them here the same for convenience, but in a real model they will probably differ.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We also modify the agent_step! function, so that we keep track of how long the agent has been infected, and whether they have to die or not.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"function sir_agent_step!(agent, model)\n    move_agent!(agent, model, model.properties[:dt])\n    update!(agent)\n    recover_or_die!(agent, model)\nend\n\nupdate!(agent) = agent.status == :I && (agent.days_infected += 1)\n\nfunction recover_or_die!(agent, model)\n    if agent.days_infected ≥ model.properties[:infection_period]\n        if rand() ≤ model.properties[:death_rate]\n            kill_agent!(agent, model)\n        else\n            agent.status = :R\n            agent.days_infected = 0\n        end\n    end\nend","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Alright, now we can animate this process for default parameters","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"sir_model = sir_initiation()\n\nanim = @animate for i ∈ 1:1000\n    p1 = plotabm(sir_model; ac = sir_colors, as = 4)\n    title!(p1, \"step $(i)\")\n    step!(sir_model, sir_agent_step!, sir_model_step!, 1)\nend\ngif(anim, \"socialdist4.gif\", fps = 45);\nnothing #hide","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"(Image: )","category":"page"},{"location":"examples/social_distancing/#Exponential-spread-1","page":"Continuous space social distancing for COVID-19","title":"Exponential spread","text":"","category":"section"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Alright, we can all agree that these animations are cool, but let's do some actual analysis of this model. The interesting quantity is the number of infected over time, so let's calculate this, similarly with the graph SIR model.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"infected(x) = count(i == :I for i in x)\nrecovered(x) = count(i == :R for i in x)\npropert = Dict(:status => [infected, length])","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Let's do the following runs, with different parameters probabilities","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"r1, r2 = 0.04, 0.33\nβ1, β2 = 0.5, 0.1\nsir_model1 = sir_initiation(reinfection_probability = r1, βmin = β1)\nsir_model2 = sir_initiation(reinfection_probability = r2, βmin = β1)\nsir_model3 = sir_initiation(reinfection_probability = r1, βmin = β2)\n\ndata1 = step!(sir_model1, sir_agent_step!, sir_model_step!, 2000, propert)\ndata2 = step!(sir_model2, sir_agent_step!, sir_model_step!, 2000, propert)\ndata3 = step!(sir_model3, sir_agent_step!, sir_model_step!, 2000, propert)\n\ndata1[end-10:end, :]","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Now, we can plot the number of infected versus time","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"p = plot(data1[:, Symbol(\"infected(status)\")], label = \"r=$r1, beta=$β1\")\nplot!(p, data2[:, Symbol(\"infected(status)\")], label = \"r=$r2, beta=$β1\")\nplot!(p, data3[:, Symbol(\"infected(status)\")], label = \"r=$r1, beta=$β2\")\nyaxis!(p, \"Infected\")\np","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"The exponential growth is quite clear in all cases.","category":"page"},{"location":"examples/social_distancing/#Social-distancing-1","page":"Continuous space social distancing for COVID-19","title":"Social distancing","text":"","category":"section"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Of course in reality a dampening mechanism will (hopefully) happen before all population is infected: a vaccine. This effectively introduces a 4th type of status, :V for vaccinated. This type can't get infected, and thus all remaining individuals that are already infected will (hopefully) survive or die out.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Until that point, social distancing is practiced. The best way to model social distancing is to make some agents simply not move (which feels like it approximates reality better).","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"sir_model = sir_initiation(isolated = 0.8)\n\nanim = @animate for i ∈ 1:1000\n    p1 = plotabm(sir_model; ac = sir_colors, as = 4)\n    title!(p1, \"step $(i)\")\n    step!(sir_model, sir_agent_step!, sir_model_step!, 1)\nend\ngif(anim, \"socialdist5.gif\", fps = 45);\nnothing #hide","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"(Image: )","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Here we let some 20% of the population not being isolated, probably teenagers still partying, or anti-vaxxers / flat-earthers that don't believe in science. Still, you can see that the spread of the virus is dramatically contained.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Let's look at the actual numbers, because animations are cool, but science is even cooler.","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"r4 = 0.04\nsir_model4 = sir_initiation(reinfection_probability = r4, βmin = β1, isolated = 0.8)\n\ndata4 = step!(sir_model4, sir_agent_step!, sir_model_step!, 2000, propert)\n\nplot!(p, data4[:, Symbol(\"infected(status)\")], label = \"r=$r4, social distancing\")\np","category":"page"},{"location":"examples/social_distancing/#","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Here you can see the characteristic \"flatten the curve\" phrase you hear all over the news.","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/wealth_distribution.jl\"","category":"page"},{"location":"examples/wealth_distribution/#Wealth-distribution-model-1","page":"Wealth distribution","title":"Wealth distribution model","text":"","category":"section"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"This model is a simple agent-based economy that is modelled according to the work of Dragulescu et al.. This work introduces statistical mechanics concepts to study wealth distributions. For this reason what we show here is also referred to as \"Boltzmann wealth distribution\" model.","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"This model has a version with and without space. The rules of the space-less game are quite simple:","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"There is a pre-determined number of agents.\nAll agents start with one unit of wealth.\nAt every step an agent gives 1 unit of wealth (if they have it) to some other agent.","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"Even though these are some very simple rules, they can still create the basic properties of wealth distributions, e.g. power-laws distributions.","category":"page"},{"location":"examples/wealth_distribution/#Core-structures,-space-less-1","page":"Wealth distribution","title":"Core structures, space-less","text":"","category":"section"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"We start by defining the Agent type and initializing the model.","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"using Agents\nmutable struct WealthAgent <: AbstractAgent\n    id::Int\n    wealth::Int\nend","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"Notice that this agent does not have a pos field. That is okay, because there is no space structure to this example. We can also make a very simple AgentBasedModel for our model.","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"function wealth_model(;numagents = 100, initwealth = 1)\n    model = ABM(WealthAgent, scheduler=random_activation)\n    for i in 1:numagents\n        add_agent!(model, initwealth)\n    end\n    return model\nend\n\nmodel = wealth_model()","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"The next step is to define the agent step function","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"function agent_step!(agent, model)\n    agent.wealth == 0 && return # do nothing\n    ragent = random_agent(model)\n    agent.wealth -= 1\n    ragent.wealth += 1\nend","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"We use random_agent as a convenient way to just grab a random agent. (this may return the same agent as agent, but we don't care in the long run)","category":"page"},{"location":"examples/wealth_distribution/#Running-the-space-less-model-1","page":"Wealth distribution","title":"Running the space-less model","text":"","category":"section"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"Let's do some data collection, running a large model for a lot of time","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"N = 5\nM = 2000\nagent_properties = [:wealth]\nmodel = wealth_model(numagents=M)\ndata = step!(model, agent_step!, N, agent_properties)\ndata[end-20:end, :]","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"What we mostly care about is the distribution of wealth, which we can obtain for example by doing the following query:","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"wealths = filter(x -> x.step == N, data)[!, :wealth]","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"and then we can make a histogram of the result. With a simple visualization we immediatelly see the power-law distribution:","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"using UnicodePlots\nUnicodePlots.histogram(wealths)","category":"page"},{"location":"examples/wealth_distribution/#Core-structures,-with-space-1","page":"Wealth distribution","title":"Core structures, with space","text":"","category":"section"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"We now expand this model to (in this case) a 2D grid. The rules are the same but agents exchange wealth only with their neighbors. We therefore have to add a pos field as the second field of the agents:","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"mutable struct WealthInSpace <: AbstractAgent\n    id::Int\n    pos::NTuple{2, Int}\n    wealth::Int\nend\n\nfunction wealth_model_2D(;dims = (25,25), wealth = 1, M = 1000)\n  space = GridSpace(dims, periodic = true)\n  model = ABM(WealthInSpace, space; scheduler = random_activation)\n  for i in 1:M # add agents in random nodes\n      add_agent!(model, wealth)\n  end\n  return model\nend\n\nmodel2D = wealth_model_2D()","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"The agent actions are a just a bit more complicated in this example. Now the agents can only give wealth to agents that exist on the same or neighboring nodes (their \"neighbhors\").","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"function agent_step_2d!(agent, model)\n    agent.wealth == 0 && return # do nothing\n    agent_node = coord2vertex(agent.pos, model)\n    neighboring_nodes = node_neighbors(agent_node, model)\n    push!(neighboring_nodes, agent_node) # also consider current node\n    rnode = rand(neighboring_nodes) # the node that we will exchange with\n    available_agents = get_node_contents(rnode, model)\n    if length(available_agents) > 0\n        random_neighbor_agent = id2agent(rand(available_agents), model)\n        agent.wealth -= 1\n        random_neighbor_agent.wealth += 1\n    end\nend","category":"page"},{"location":"examples/wealth_distribution/#Running-the-model-with-space-1","page":"Wealth distribution","title":"Running the model with space","text":"","category":"section"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"using Random\nRandom.seed!(5)\ninit_wealth = 4\nmodel = wealth_model_2D(;wealth = init_wealth)\nagent_properties = [:wealth, :pos]\ndata = step!(model, agent_step!, 10, agent_properties, when = [1, 5, 10], step0=false)\ndata[end-20:end, :]","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"Okay, now we want to get the 2D spatial wealth distribution of the model. That is actually straightforward:","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"function wealth_distr(data, model, n)\n    W = zeros(Int, size(model.space))\n    for row in eachrow(filter(r -> r.step == n, data)) # iterate over rows at a specific step\n        W[row.pos...] += row.wealth\n    end\n    return W\nend\n\nW1 = wealth_distr(data, model2D, 1)\nW5 = wealth_distr(data, model2D, 5)\nW10 = wealth_distr(data, model2D, 10)","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"using Plots\nPlots.heatmap(W1)","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"Plots.heatmap(W5)","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"Plots.heatmap(W10)","category":"page"},{"location":"examples/wealth_distribution/#","page":"Wealth distribution","title":"Wealth distribution","text":"What we see is that wealth gets more and more localized.","category":"page"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/rule22_1D_CA.jl\"","category":"page"},{"location":"examples/rule22_1D_CA/#One-dimensional-cellular-automata-1","page":"Rule 22","title":"One-dimensional cellular automata","text":"","category":"section"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"Agents.jl provides a module (CA1D) to create and plot 1D cellular automata.","category":"page"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"using Agents\nusing Agents.CA1D\nusing AgentsPlots","category":"page"},{"location":"examples/rule22_1D_CA/#.-Define-the-rule-1","page":"Rule 22","title":"1. Define the rule","text":"","category":"section"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"Here is Wolfram's rule 22","category":"page"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"rules = Dict(\"111\"=>\"0\", \"110\"=>\"0\", \"101\"=>\"0\", \"100\"=>\"1\", \"011\"=>\"0\",\n            \"010\"=>\"1\", \"001\"=>\"1\", \"000\"=>\"0\")","category":"page"},{"location":"examples/rule22_1D_CA/#.-Build-the-model-1","page":"Rule 22","title":"2. Build the model","text":"","category":"section"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"All the cells are by default initially \"off\"","category":"page"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"model = CA1D.build_model(rules=rules, ncols=21)","category":"page"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"This turns on the middle cell","category":"page"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"model.agents[11].status=\"1\"","category":"page"},{"location":"examples/rule22_1D_CA/#.-Run-the-model-and-collect-data.-1","page":"Rule 22","title":"3. Run the model and collect data.","text":"","category":"section"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"runs = 20\ndata = CA1D.ca_run(model, runs);\nnothing #hide","category":"page"},{"location":"examples/rule22_1D_CA/#.-Visualize-the-data-1","page":"Rule 22","title":"4. Visualize the data","text":"","category":"section"},{"location":"examples/rule22_1D_CA/#","page":"Rule 22","title":"Rule 22","text":"p = plot_CA1D(data, nodesize=2)","category":"page"},{"location":"#Agents.jl-Documentation-1","page":"Introduction","title":"Agents.jl Documentation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: Agents.jl)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Agents.jl is a Julia framework for agent-based modeling (ABM). Agents.jl is part of JuliaDynamics. To get started, please read the Tutorial page.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"info: Latest news\nYou are currently reading the development version of the documentation, which is being prepared for Agents.jl 3.0. In this major release we have full support for agent based models on ContinuousSpace, but have not yet finished development. See the CHANGELOG for a full list of changes. This documentation only makes sense if you use master version for Agents and AgentsPlots.","category":"page"},{"location":"#Features-1","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Intuitive, small yet powerful, and simple to learn API for agent based models.\nUniversal model structure where agents are identified by a unique id: AgentBasedModel\nSupport for all possible types of spaces: arbitrary graphs, regular grids, or continuous space.\nScheduler interface (with default schedulers), making it easy to activate agents in a specific order (e.g. by the value of some property)\nAutomatic data collection in a DataFrame at desired intervals\nAggregating collected data during model evolution\nDistributed computing\nBatch running and batch data collection\nVisualize agent distributions on regular grids, arbitrary graphs or continuous space.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The package is in Julia's package list. Install it using this command:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"]add Agents","category":"page"},{"location":"#Comparison-with-existing-software-1","page":"Introduction","title":"Comparison with existing software","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Many agent-based modeling frameworks have been constructed to ease the process of building and analyzing ABMs (see here for a review). Notable examples are NetLogo, Repast, MASON, and Mesa.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Implementing an ABM framework in Julia has several advantages:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Using a general purpose programming language instead of a custom scripting language, such as NetLogo's, removes a learning step and provides a single environment for building the models and analyzing their results.\nJulia has a rich ecosystem for data analysis and visualization, implemented and maintained independently from Agents.jl.\nJulia is easier-to-use than Java (used for Repast and MASON), and provides a REPL (Read-Eval-Print-Loop) environment to build and analyze models interactively.\nUnlike Python (used for Mesa), Julia is fast to run. This is a crucial criterion for models that require considerable computations.\nBecause the direct output of Agents.jl is a DataFrame, it makes it easy to use tools such as DataVoyager.jl, which provide an interactive environment to build custom plots from DataFrames. (and of course the DataFrame itself is a tabular data format similar to Python's Pandas).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Agents.jl is lightweight and modular. It has a short learning curve, and allows one to extend its capabilities and express complicated modeling scenarios. Agents.jl was originally inspired by the Mesa framework for Python, but has since then departed in design, leading to a dramatically simpler and cleaner API and a shorter learning curve, besides having obvious performance benefits (more than 10 times better performance than Mesa, see our Agents.jl vs Mesa: speed comparison).","category":"page"},{"location":"#Crash-course-on-agent-based-modeling-1","page":"Introduction","title":"Crash course on agent based modeling","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"An agent-based (or individual-based) model is a computational simulation of autonomous agents that react to their environment (including other agents) given a predefined set of rules [1]. ABM has gained wide usage in a variety of research disciplines. One reason for its popularity is that it allows relaxing many simplifying assumptions usually made by mathematical models. Relaxing such assumptions of a \"perfect world\" can change a model's behavior [2]. ABM is specifically an important tool for studying complex systems where a system's behavior cannot be predicted and has to be explored (see the \"Why we need ABM\" section for detailed examples).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Agent-based models are increasingly recognized as the approach for studying complex systems [3,4,5,6]. Complex systems cannot be fully understood using the traditional mathematical tools that aggregate the behavior of elements in a system. The behavior of a complex system depends on the behavior and interaction of its elements (agents). Small changes in the input to complex systems or the behavior of its agents can lead to large changes in system's outcome. That is to say a complex system's behavior is nonlinear, and that it is not the sum of the behavior of its elements. Use of ABMs have become feasible after the availability of computers and has been growing since, especially in modeling biological and economical systems, and has extended to social studies and archaeology.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"An ABM consists of autonomous agents that behave given a set of rules. A classic example of an ABM is Schelling's segregation model, which we implement as an example here. This model also uses a regular grid and defines agents as the cells of the grid. Agents can be from different social groups. Agents are happy/unhappy based on the fraction of their neighbors that belong to the same group as they are. If they are unhappy, they keep moving to new locations until they are happy. Schelling's model shows that even small preferences of agents to have neighbors belonging to the same group (e.g. preferring that at least 30% of neighbors to be in the same group) could lead to total segregation of neighborhoods. This is another example of an emergent phenomenon from simple interactions of agents.","category":"page"},{"location":"#Citation-1","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you use this package in a publication, please cite the paper below:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"R. Vahdati, Ali (2019). Agents.jl: agent-based modeling framework in Julia. Journal of Open Source Software, 4(42), 1611, https://doi.org/10.21105/joss.01611","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Agents.jl is composed of components for building models, building and managing space structures, collecting data, running batch simulations, and data visualization.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Agents.jl structures simulations in three components: a model component that keeps all model-level variables and data, an agent component that keeps all agent-level variables and data, and a space component that represents the space where the agents live.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"For building any Agent-Based-Model (ABM), users have to define at least the following four quantities:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"An AgentBasedModel instance.\nA space instance.\nA subtype of AbstractAgent for the agents.\nA stepping function that controls how the agents and the model evolve.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"With these, Agents.jl's tools manage the rest of the path to producing and processing data, as well as visualizations (Fig. 1).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Fig. 1. __Path from building a model to gaining information from the model using Agents.jl.__ The box in cyan is what the user has to provide and the boxes in green are what Agents.jl provides.)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Fig. 2. __Fields of a model object and their types.__)","category":"page"},{"location":"tutorial/#.-The-model-1","page":"Tutorial","title":"1. The model","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"AgentBasedModel","category":"page"},{"location":"tutorial/#Agents.AgentBasedModel","page":"Tutorial","title":"Agents.AgentBasedModel","text":"AgentBasedModel(agent_type [, space]; scheduler, properties)\n\nCreate an agent based model from the given agent type, and the space (from Space). ABM is equivalent with AgentBasedModel. The agents are stored in a dictionary model.agents, where the keys are the agent IDs, while the values are the agents themselves. It is recommended however to use id2agent to get an agent.\n\nspace can be omitted, in which it will equal to nothing. This means that all agents are virtually in one node and have no spatial structure. If space is omitted, some functions that facilitate agent-space interactions will not work.\n\nOptionally provide a scheduler that creates the order with which agents are activated in the model, and properties for additional model-level properties. This is accessed as model.properties for later use.\n\n\n\n\n\nAgentBasedModel(agent_instance [, space]; scheduler, properties)\n\nSimilar to the constructor above, but created via an instance of your agent.\n\nmutable struct YourAgent <: AbstractAgent\n    id::Int\n    pos::Tuple{Int, Int}\nend\nagent = YourAgent(1, (1,1))\nmodel = AgentBasedModel(agent, GridSpace((10,10))\n\nNote that the specific values you use when creating agent_instance are not important and wont be used here. This process just helps Agents.jl do some performance checks for you, if you're not that familiar with Julia's type system.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Space-1","page":"Tutorial","title":"2. The space","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Agents.jl offers several possibilities for the space the agents live in, separated into discrete and continuous categories (notice that using a space is not actually necessary).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The discrete possibilities are","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"GraphSpace\nGridSpace","category":"page"},{"location":"tutorial/#Agents.GraphSpace","page":"Tutorial","title":"Agents.GraphSpace","text":"GraphSpace(graph::AbstractGraph)\n\nCreate a GraphSpace instance that is underlined by an arbitrary graph from LightGraphs.jl. In this case, your agent type must have a pos field that is of type Int.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Agents.GridSpace","page":"Tutorial","title":"Agents.GridSpace","text":"GridSpace(dims::NTuple; periodic = false, moore = false) → GridSpace\n\nCreate a GridSpace instance that represents a grid of dimensionality length(dims), with each dimension having the size of the corresponding entry of dims. Such grids are typically used in cellular-automata-like models. In this case, your agent type must have a pos field that is of type NTuple{Int}.\n\nThe two keyword arguments denote if the grid should be periodic on its ends, and if the connections should be of type Moore or not (in the Moore case the diagonal connections are also valid. E.g. for a 2D grid, each node has 8 neighbors).\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"and the continuous version is","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"ContinuousSpace","category":"page"},{"location":"tutorial/#Agents.ContinuousSpace","page":"Tutorial","title":"Agents.ContinuousSpace","text":"ContinuousSpace(D::Int [, update_vel!]; periodic::Bool = true, extend = nothing, metric = \"cityblock\")\n\nCreate a ContinuousSpace of dimensionality D. In this case, your agent positions (field pos) should be of type NTuple{D, F} where F <: AbstractFloat. In addition, the agent type must have a third field vel::NTuple{D, F} representing the agent's velocity.\n\nThe optional argument update_vel! is a function, update_vel!(agent, model) that updates the agent's velocities before the agent has been moved, see move_agent!. You can of course change the agents velocities during the agent interaction, the update_vel! functionality targets arbitrary forces. By default no update is done this way.\n\nKeywords\n\nperiodic = true : whether continuous space is periodic or not\nextend::NTuple{D} = ones : Extend of space. The d dimension starts at 0 and ends at extend[d]. If periodic = true, this is also when periodicity occurs. If periodic ≠ true, extend is only used at plotting.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#.-The-agent-1","page":"Tutorial","title":"3. The agent","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"AbstractAgent","category":"page"},{"location":"tutorial/#Agents.AbstractAgent","page":"Tutorial","title":"Agents.AbstractAgent","text":"All agents must be a mutable subtype of AbstractAgent. Your agent type must have the id field as first field. Depending on the space structure there might be a pos field of appropriate type and a vel field of appropriate type.\n\nYour agent type may have other additional fields relevant to your system, for example variable quantities like \"status\" or other \"counters\".\n\nExamples\n\nImagine agents who have extra properties weight, happy. For a GraphSpace we would define them like\n\nmutable struct ExampleAgent <: AbstractAgent\n    id::Int\n    pos::Int\n    weight::Float64\n    happy::Bool\nend\n\nwhile for e.g. a ContinuousSpace we would use\n\nmutable struct ExampleAgent <: AbstractAgent\n    id::Int\n    pos::NTuple{2, Float64}\n    vel::NTuple{2, Float64}\n    weight::Float64\n    happy::Bool\nend\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The agent type must be mutable. Once an Agent is created it can be added to a model using e.g. add_agent!. Then, the agent can interact with the model and the space further by using e.g. move_agent! or kill_agent!.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"For more functions visit the API page.","category":"page"},{"location":"tutorial/#.-The-stepping-function-1","page":"Tutorial","title":"4. The stepping function","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Any ABM model should have at least one and at most two step functions. An agent step function is always required. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a model step function.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"An agent step function should only accept two arguments: first, an agent object, and second, a model object.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The model step function should accept only one argument, that is the model object. To use only a model step function, users can use the built-in dummystep as the agent step function.","category":"page"},{"location":"tutorial/#.-Running-the-model-and-collecting-data-1","page":"Tutorial","title":"5. Running the model & collecting data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"After the basic types and functions are defined, we can run the model using the built-in step! function. This will update the agents and the model as defined by the agent and model stepping functions. In addition, by providing keywords to step!, it is also possible to collect and process data while the model evolves.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Agents.step!","category":"page"},{"location":"tutorial/#Agents.step!","page":"Tutorial","title":"Agents.step!","text":"step!(model, agent_step! [, model_step!], n::Integer = 1)\n\nUpdate agents n steps. Agents will be updated as specified by the model.scheduler. If given the optional function model_step!, it is triggered after every scheduled agent has acted.\n\nstep!(model, agent_step! [, model_step!], n::Function)\n\nn can be also be a function that takes as an input the model and returns true/false. Then step! runs the model until n(model) returns true.\n\nstep!(model, agent_step! [, model_step!], n, properties; kwargs...)\n\nThis version of step!, with the properties argument and extra keywords, performs data collection/processing while running the model.\n\nproperties dictates which agent fields should be collected as data. It can be either an array, in which case, the specified fields of all agents will be saved. Or it can be a dictionary, in which case it should map agent fields (Symbol) to functions.\n\nIf properties is an array, each row of the output DataFrame corresponds to a single agent and each column is a requested field value.\n\nIf properties is a dictionary, each row of the output DataFrame corresponds to all agents and each column is the a function applied to a field. The functions in a dictionary properties are applied to the collected fields, that is, the keys of properties. For example, if your agents have a field called wealth, and you want to calculate mean and median population wealth at steps defined by when, your properties dict will be Dict(:wealth => [mean, median]).\n\nIf an agent field returns an array instead of a single number, the mean of that array will be calculated before the functions are applied to them.\n\nCollected data always also include the initial status of the model at step 0.\n\nTo apply a function to the list of agents, use :agent as a dictionary key. To apply a function to the model object, use :model as a dictionary key.\n\nKeywords\n\nwhen=1:n : at which steps n to perform the data collection and processing.\nreplicates : Optional. Run replicates replicates of the simulation. Defaults to 0.\nparallel : Optional. Only when replicates>0. Run replicate simulations in parallel. Defaults to false.\nstep0: Whether to collect data at step zero, before running the model. Defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Notice that besides step!, there is also the paramscan function that performs data collection, while scanning ranges of the parameters of the model.","category":"page"},{"location":"tutorial/#An-educative-example-1","page":"Tutorial","title":"An educative example","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A simple, education-oriented example of using the basic Agents.jl API is given in Schelling's segregation model. There the visualization aspect is also discussed.","category":"page"}]
}
